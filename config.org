#+title: GNU Emacs configuration
#+author: Srijan Choudhary
#+email: srijan4@gmail.com
#+language: en
#+options: ':t toc:nil num:t author:t email:t
#+startup: content indent
#+macro: latest-export-date (eval (format-time-string "%F %T %z"))
#+macro: word-count (eval (count-words (point-min) (point-max)))

*Last revised and exported on {{{latest-export-date}}} with a word
count of {{{word-count}}}.*

This is my literate Emacs configuration file.

I use minimal-emacs.d as the baseline for my config. It provides two main files:
- early-init.el
- init.el

Apart from these, it allows me to insert configuration as required into the following files:
- pre-early-init.el
- post-early-init.el
- pre-init.el
- post-init.el


When I want to modify my Emacs setup, I edit this file and then
evaluate the following code block or do =C-c C-v C-t=. All files will
be updated accordingly.

#+begin_src emacs-lisp :tangle no :results none
  (org-babel-tangle)
#+end_src

* pre-early-init

This file has the config that has to be loaded before the rest of the minimal-emacs.d code is run

#+begin_src emacs-lisp :tangle "pre-early-init.el"
  ;;; pre-early-init.el --- -*- no-byte-compile: t; lexical-binding: t; -*-

  (setq minimal-emacs-ui-features '(context-menu menu-bar dialogs tooltips))

  ;; Reducing clutter in ~/.emacs.d by redirecting files to ~/emacs.d/var/
  (setq minimal-emacs-var-dir (expand-file-name "var/" minimal-emacs-user-directory))
  (setq package-user-dir (expand-file-name "elpa" minimal-emacs-var-dir))
  (setq user-emacs-directory minimal-emacs-var-dir)

  ;; By default, minimal-emacs-package-initialize-and-refresh is set to t, which
  ;; makes minimal-emacs.d call the built-in package manager. Since Elpaca will
  ;; replace the package manager, there is no need to call it.
  (setq minimal-emacs-package-initialize-and-refresh nil)

  (defun display-startup-time ()
    "Display the startup time and number of garbage collections."
    (message "Emacs init loaded in %.2f seconds (Full emacs-startup: %.2fs) with %d garbage collections."
             (float-time (time-subtract after-init-time before-init-time))
             (time-to-seconds (time-since before-init-time))
             gcs-done))

  (add-hook 'emacs-startup-hook #'display-startup-time 100)
#+end_src

* post-early-init

#+begin_src emacs-lisp :tangle "post-early-init.el"
  ;;; post-early-init.el --- -*- no-byte-compile: t; lexical-binding: t; -*-
  (when (not (null (getenv "ANDROID_ROOT")))
    (setenv "PATH" (format "%s:%s" "/data/data/com.termux/files/usr/bin"
                           (getenv "PATH")))
    (push "/data/data/com.termux/files/usr/bin" exec-path))
#+end_src

* pre-init

#+begin_src emacs-lisp :tangle "pre-init.el"
  ;;; pre-init.el --- -*- no-byte-compile: t; lexical-binding: t; -*-
#+end_src

*** Elpaca

#+begin_src emacs-lisp :tangle "pre-init.el"
  (defvar elpaca-installer-version 0.11)
  (defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
  (defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
  (defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
  (defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
                                :ref nil :depth 1 :inherit ignore
                                :files (:defaults "elpaca-test.el" (:exclude "extensions"))
                                :build (:not elpaca--activate-package)))
  (let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
         (build (expand-file-name "elpaca/" elpaca-builds-directory))
         (order (cdr elpaca-order))
         (default-directory repo))
    (add-to-list 'load-path (if (file-exists-p build) build repo))
    (unless (file-exists-p repo)
      (make-directory repo t)
      (when (<= emacs-major-version 28) (require 'subr-x))
      (condition-case-unless-debug err
          (if-let* ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                    ((zerop (apply #'call-process `("git" nil ,buffer t "clone"
                                                    ,@(when-let* ((depth (plist-get order :depth)))
                                                        (list (format "--depth=%d" depth) "--no-single-branch"))
                                                    ,(plist-get order :repo) ,repo))))
                    ((zerop (call-process "git" nil buffer t "checkout"
                                          (or (plist-get order :ref) "--"))))
                    (emacs (concat invocation-directory invocation-name))
                    ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
                                          "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                    ((require 'elpaca))
                    ((elpaca-generate-autoloads "elpaca" repo)))
              (progn (message "%s" (buffer-string)) (kill-buffer buffer))
            (error "%s" (with-current-buffer buffer (buffer-string))))
        ((error) (warn "%s" err) (delete-directory repo 'recursive))))
    (unless (require 'elpaca-autoloads nil t)
      (require 'elpaca)
      (elpaca-generate-autoloads "elpaca" repo)
      (let ((load-source-file-function nil)) (load "./elpaca-autoloads"))))
  (add-hook 'after-init-hook #'elpaca-process-queues)
  (elpaca `(,@elpaca-order))

  ;; Optional: Install use-package support
  (elpaca elpaca-use-package
    (elpaca-use-package-mode))

  (setopt use-package-compute-statistics t)
  (setopt use-package-always-defer t)

  ;; Lock file
  ;; (setq elpaca-lock-file (expand-file-name "elpaca-lock.eld" minimal-emacs-user-directory))
#+end_src

* post-init
** Header
This will generate a header at the top of the tangled file to indicate it is generated and is not meant to be modified directly.

#+begin_src emacs-lisp :tangle "post-init.el" :epilogue (format-time-string ";; Last generated on %c")
  ;;; post-init.el --- -*- no-byte-compile: t; lexical-binding: t; -*-
  ;; This file has been generated from config.org file. DO NOT EDIT.
#+end_src
** Load my custom libraries
#+begin_src emacs-lisp :tangle "post-init.el"
  (add-to-list 'load-path (expand-file-name "srijan-lisp" minimal-emacs-user-directory))
#+end_src

** System information
#+begin_src emacs-lisp :tangle "post-init.el"
  (defvar my-linux-p (eq system-type 'gnu/linux))
  (defvar my-windows-p (eq system-type 'windows-nt))
  (defvar my-mac-p (eq system-type 'darwin))
  (defvar my-phone-p (not (null (getenv "ANDROID_ROOT")))
    "If non-nil, GNU Emacs is running on Termux.")
  (when my-phone-p (setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3"))
  (when my-mac-p (setopt server-use-tcp t))
  (server-start)
#+end_src
** COMMENT Compile Angel
Speed up Emacs by Automatically Byte-compiling and Native-compiling all .el files

TODO: Need to evaluate how much speedup this gives

#+begin_src emacs-lisp :tangle "post-init.el"
  (use-package compile-angel
    :ensure t
    :demand t
    :custom
    ;; Set `compile-angel-verbose` to nil to suppress output from compile-angel.
    ;; Drawback: The minibuffer will not display compile-angel's actions.
    (compile-angel-verbose t)

    :config
    ;; The following directive prevents compile-angel from compiling your init
    ;; files. If you choose to remove this push to `compile-angel-excluded-files'
    ;; and compile your pre/post-init files, ensure you understand the
    ;; implications and thoroughly test your code. For example, if you're using
    ;; `use-package', you'll need to explicitly add `(require 'use-package)` at
    ;; the top of your init file.
    (push "/pre-init.el" compile-angel-excluded-files)
    (push "/post-init.el" compile-angel-excluded-files)
    (push "/pre-early-init.el" compile-angel-excluded-files)
    (push "/post-early-init.el" compile-angel-excluded-files)
    (push "/org-clock-save.el" compile-angel-excluded-files)

    ;; A local mode that compiles .el files whenever the user saves them.
    ;; (add-hook 'emacs-lisp-mode-hook #'compile-angel-on-save-local-mode)

    ;; A global mode that compiles .el files before they are loaded.
    (compile-angel-on-load-mode))
#+end_src
** Personal Information

#+begin_src emacs-lisp :tangle "post-init.el"
  (setq user-full-name "Srijan Choudhary"
        user-mail-address "srijan4@gmail.com")
#+END_SRC
** Linux Specific
#+begin_src emacs-lisp :tangle "post-init.el"
  (when my-linux-p
    (defun sj/insert-org-from-html-clipboard ()
      (interactive)
      (let* ((not-nil-and-not-a-buffer-means-current-buffer 1)
             (dst-buffer not-nil-and-not-a-buffer-means-current-buffer)
             (command "wl-paste --type text/html | pandoc -f html -t org"))
        (shell-command command dst-buffer))))
#+end_src
** Mac Specific
#+begin_src emacs-lisp :tangle "post-init.el"
  (when my-mac-p
    ;; Swap Alt (Option) and Super (Command) keys
    ;; (setq mac-option-modifier 'super)        ; Left Option key becomes Super
    ;; (setq mac-command-modifier 'meta)        ; Command key becomes Meta (Alt)
    ;; (setq mac-right-option-modifier 'none)   ; Right Option for special characters

    (setq insert-directory-program "/opt/homebrew/bin/gls")

    (use-package exec-path-from-shell
      :ensure t
      :demand t
      :config
      (add-to-list 'exec-path-from-shell-variables "ANTHROPIC_API_KEY")
      (add-to-list 'exec-path-from-shell-variables "TODOIST_TOKEN")
      (exec-path-from-shell-initialize))

    (use-package emacs-anywhere
      :disabled
      :ensure (:host github :repo "nohzafk/emacs-anywhere")
      :demand t)
    )
#+end_src
** Misc config

#+begin_src emacs-lisp :tangle "post-init.el"

  (defun my-reload-emacs-configuration ()
    (interactive)
    (load-file (expand-file-name "init.el" minimal-emacs-user-directory)))

  ;; Open the config file
  (global-set-key (kbd "C-x ,") (lambda() (interactive) (find-file (expand-file-name "config.org" minimal-emacs-user-directory))))

  ;; Custom file
  (setq custom-file null-device)

  ;; Auto-revert in Emacs is a feature that automatically updates the
  ;; contents of a buffer to reflect changes made to the underlying file
  ;; on disk.
  (add-hook 'after-init-hook #'global-auto-revert-mode)

  ;; recentf is an Emacs package that maintains a list of recently
  ;; accessed files, making it easier to reopen files you have worked on
  ;; recently.
  (add-hook 'after-init-hook #'(lambda()
                                 (let ((inhibit-message t))
                                   (recentf-mode 1))))
  (add-hook 'kill-emacs-hook #'recentf-cleanup)

  ;; savehist is an Emacs feature that preserves the minibuffer history between
  ;; sessions. It saves the history of inputs in the minibuffer, such as commands,
  ;; search strings, and other prompts, to a file. This allows users to retain
  ;; their minibuffer history across Emacs restarts.
  (add-hook 'after-init-hook #'savehist-mode)

  ;; save-place-mode enables Emacs to remember the last location within a file
  ;; upon reopening. This feature is particularly beneficial for resuming work at
  ;; the precise point where you previously left off.
  (add-hook 'after-init-hook #'save-place-mode)

  ;; Enable `auto-save-mode' to prevent data loss. Use `recover-file' or
  ;; `recover-session' to restore unsaved changes.
  (setq auto-save-default t)
  (setq auto-save-interval 300)
  (setq auto-save-timeout 30)

  ;; Hide warnings and display only errors
  (setq warning-minimum-level :error)

  ;; Disable momentum-based scrolling for precise control and enable smoother scrolling.
  (setq pixel-scroll-precision-use-momentum 1)
  (pixel-scroll-precision-mode 1)

  ;; Pixel Scroll Precision Mode on Emacs for macOS: If you're using a pre-built
  ;; emacs-mac (version <= 29.1), smooth scrolling is handled by the Mac port
  ;; code, which overrides `pixel-scroll-precision-mode'. In this case, use the
  ;; following line instead of enabling `pixel-scroll-precision-mode':
  ;;
  ;; (pixel-scroll-mode t)
  ;;
  ;; For more details, see:
  ;; https://bitbucket.org/mituharu/emacs-mac/commits/65c6c96f27afa446df6f9d8eff63f9cc012cc738

  ;; Display the time in the modeline
  (display-time-mode 1)

  ;; Paren match highlighting
  (show-paren-mode 1)

  ;; Replace selected text with typed text
  (delete-selection-mode 1)

  ;; Configure Emacs to ask for confirmation before exiting
  ;; (setq confirm-kill-emacs 'y-or-n-p)

  ;; Automatically hide file details (permissions, size, modification date, etc.)
  ;; in Dired buffers for a cleaner display.
  (add-hook 'dired-mode-hook #'dired-hide-details-mode)

  ;; Kill current buffer (instead of asking first buffer name)
  (global-set-key (kbd "C-x k") 'kill-current-buffer)

  ;; M-n for new frame (M-n is unbound in vanilla emacs)
  (defun new-frame ()
    (interactive)
    (select-frame (make-frame))
    (switch-to-buffer "*scratch*"))
  (global-set-key (kbd "M-n") 'new-frame)

  (setq save-interprogram-paste-before-kill t)

  (global-visual-line-mode 1)

  (defun kill-region-or-backward-word ()
    "If the region is active and non-empty, call `kill-region'.
  Otherwise, call `backward-kill-word'."
    (interactive)
    (call-interactively
     (if (use-region-p) 'kill-region 'backward-kill-word)))
  (global-set-key (kbd "C-w") 'kill-region-or-backward-word)

#+end_src
** Discoverability
#+begin_src emacs-lisp :tangle "post-init.el"

  (use-package which-key
    :ensure nil ; builtin
    :defer t
    :commands which-key-mode
    :hook (after-init . which-key-mode)
    :custom
    (which-key-idle-delay 1.5)
    (which-key-idle-secondary-delay 0.25)
    (which-key-add-column-padding 1)
    (which-key-max-description-length 40))

  (use-package uniquify
    :ensure nil
    :custom
    (uniquify-buffer-name-style 'reverse)
    (uniquify-separator "•")
    (uniquify-after-kill-buffer-p t)
    (uniquify-ignore-buffers-re "^\\*"))

  (use-package casual)

#+end_src
** Looks & Themes
*** Non-Android
#+begin_src emacs-lisp :tangle "post-init.el"
  (when (not my-phone-p)
    ;; (add-to-list 'default-frame-alist '(height . 55))
    ;; (add-to-list 'default-frame-alist '(width . 160))
    (scroll-bar-mode 1)
    (display-time-mode -1)
    (use-package ef-themes
      :if (display-graphic-p)
      :disabled
      :custom
      (ef-themes-to-toggle '(ef-maris-light ef-maris-dark))
      (ef-themes-headings
       '((0 . (variable-pitch semibold 1.2))
         (1 . (variable-pitch semibold 1.1))
         (agenda-date . (variable-pitch 1.2))
         (agenda-structure . (variable-pitch 1.4))
         (t . (variable-pitch))
         ))
      (ef-themes-mixed-fonts t)
      (ef-themes-variable-pitch-ui t)
      ;; :hook ((ef-themes-post-load . my-ef-themes-mode-line))
      ;; (ef-themes-post-load . fontaine-apply-current-preset)
      :config
      (defun my-ef-themes-mode-line ()
        "Tweak the style of the mode lines."
        (ef-themes-with-colors
         (custom-set-faces
          `(mode-line ((,c :background ,bg-mode-line :foreground ,fg-mode-line :box (:line-width 1 :color ,fg-dim))))
          `(mode-line-inactive ((,c :box (:line-width 1 :color ,bg-active)))))))
      :init
      ;; (ef-themes-select 'ef-maris-dark)
      )
    )
#+end_src
*** Mac
#+begin_src emacs-lisp :tangle "post-init.el"
  (when my-mac-p
    ;; (use-package nano-theme
    ;;   :demand t)

    (use-package modus-themes
      :ensure t
      :demand t
      :config
      ;; (require-theme 'modus-themes)
      (setq modus-themes-variable-pitch-ui t
            modus-themes-common-palette-overrides
            '((fringe unspecified)
              (bg-tab-bar bg-main)
              (bg-tab-current bg-cyan-intense)
              (bg-tab-other bg-inactive)
              ))    
      ;; (((border-mode-line-active unspecified)
      ;;   (border-mode-line-inactive unspecified)))

      (defun my/custom-faces (&rest _)
        (custom-set-faces
         '(region ((t :extend nil))))      
        ;; (set-face-font 'default "IBM Plex Mono-16")
        ;; (set-face-font 'default "Aporetic Sans Mono-17")
        ;; (set-face-font 'variable-pitch "Inter-15")
        ;; (set-face-font 'default "Berkeley Mono-15")
        (set-face-attribute 'default nil :family "Berkeley Mono" :height 140 :weight 'semilight)
        (set-face-attribute 'bold nil :weight 'regular)
        )
      (add-hook 'modus-themes-after-load-theme-hook #'my/custom-faces)
      
      (defun my/mac-apply-theme (appearance)
        "Load theme, taking current system APPEARANCE into consideration."
        (pcase appearance
          ('light (modus-themes-load-theme 'modus-operandi-tinted))
          ('dark (modus-themes-load-theme 'modus-vivendi-tinted))))

      (add-hook 'ns-system-appearance-change-functions #'my/mac-apply-theme)
      )

    (setopt ns-use-srgb-colorspace nil)
    (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
    ;; (add-to-list 'default-frame-alist '(ns-appearance . dark))

    ;; (use-package calle24 :demand t)
    )
#+end_src
*** Linux
#+begin_src emacs-lisp :tangle "post-init.el"
  (when my-linux-p
    (set-frame-font "Aporetic Sans Mono-13" nil t)
    (add-to-list 'default-frame-alist '(font . "Aporetic Sans Mono-13"))
    (load-theme 'modus-vivendi-tinted t)
    )
#+end_src
*** Phone
#+begin_src emacs-lisp :tangle "post-init.el"
  (when my-phone-p
    (load-theme 'modus-operandi-tinted t)
    (set-frame-font "Aporetic Sans Mono-17" nil t)
    (add-to-list 'default-frame-alist '(font . "Aporetic Sans Mono-17"))
    (tool-bar-mode 1)
    ;; (modifier-bar-mode 1)
    (setopt tool-bar-position 'top)
    (setopt tool-bar-button-margin 20)
    (setopt touch-screen-display-keyboard t)
    (setopt touch-screen-precision-scroll t)
    (setopt pixel-scroll-precision-use-momentum t)
    (use-package touchpad
      :ensure (:host github :repo ("awu7/touchpad-scroll-mode" . "touchpad")
                     :main "touchpad.el")
      :init
      (load "touchpad")
      (touchpad-scroll-mode)
      (setq touchpad-pixel-scroll t))
    )
#+end_src
*** Generic
#+begin_src emacs-lisp :tangle "post-init.el"
  ;; Fast and smooth scrolling
  (use-package ultra-scroll
    :disabled
    :ensure (:host github :repo "jdtsmith/ultra-scroll")
    :init
    (setq scroll-conservatively 101 ; important!
          scroll-margin 0)
    :config
    (ultra-scroll-mode 1))

  (use-package emoji
    :ensure nil
    :bind (("C-c e" . emoji-search))
    )

  (use-package olivetti
    :bind (("C-c C-=" . olivetti-mode))
    :custom
    (olivetti-style 'fancy)
    ;; (olivetti-fringe '(:background "#e5e5e5"))
    )
  (use-package spacious-padding
    :demand t
    :config
    (setq spacious-padding-subtle-frame-lines 
          '(:mode-line-active error))
    (setq spacious-padding-widths
          '( :internal-border-width 15
             :header-line-width 2
             :mode-line-width 6
             :tab-width 4
             :right-divider-width 15
             :scroll-bar-width 8
             :fringe-width 8))
    (spacious-padding-mode 1)
    )
#+end_src
** Tool Bar
I'm using tool-bar+ to be able to enable the tool-bar for certain modes/buffers.

#+begin_src emacs-lisp :tangle "post-init.el"
  (setq tool-bar-style 'image)
  ;; (tool-bar-mode 1)
  (use-package tool-bar+
    :ensure (:host github :repo "emacsmirror/tool-bar-plus")
    )
#+end_src
** Windows
#+BEGIN_SRC emacs-lisp :tangle "post-init.el"

  ;; Switching between windows. Use `ace-window`, configure using :init and :bind
  (use-package ace-window
    :ensure t
    :init
    (setq aw-scope 'frame)
    :bind ("M-o" . ace-window))

  ;; Track changes in the window configuration, allowing undoing actions such as
  ;; closing windows.
  (winner-mode 1)

  ;; Window dividers separate windows visually. Window dividers are bars that can
  ;; be dragged with the mouse, thus allowing you to easily resize adjacent
  ;; windows.
  ;; https://www.gnu.org/software/emacs/manual/html_node/emacs/Window-Dividers.html
  ;; (add-hook 'after-init-hook #'window-divider-mode)

#+END_SRC
** COMMENT Tabs
#+BEGIN_SRC emacs-lisp :tangle "post-init.el"
  (use-package tab-line
    :ensure nil
    :demand t
    :bind
    (("C-S-<tab>" . tab-line-switch-to-prev-tab)
     ("C-<iso-lefttab>" . tab-line-switch-to-prev-tab)
     ("C-<tab>" . tab-line-switch-to-next-tab))
    :config
    (global-tab-line-mode 1)
    (setq
     tab-line-new-button-show nil
     tab-line-close-button-show nil))
#+END_SRC
** Completion in region and at point

#+begin_src emacs-lisp :tangle "post-init.el"

  (use-package corfu
    :ensure t
    :defer t
    :commands (corfu-mode global-corfu-mode)

    :hook ((prog-mode . corfu-mode)
           (shell-mode . corfu-mode)
           (eshell-mode . corfu-mode))

    :custom
    ;; Hide commands in M-x which do not apply to the current mode.
    (read-extended-command-predicate #'command-completion-default-include-p)
    ;; Disable Ispell completion function. As an alternative try `cape-dict'.
    (text-mode-ispell-word-completion nil)
    (tab-always-indent 'complete)

    ;; Enable Corfu
    :config
    (global-corfu-mode))

  (use-package cape
    :ensure t
    :defer t
    :commands (cape-dabbrev cape-file cape-elisp-block)
    :bind ("C-c p" . cape-prefix-map)
    :init
    ;; Add to the global default value of `completion-at-point-functions' which is
    ;; used by `completion-at-point'.
    (add-hook 'completion-at-point-functions #'cape-dabbrev)
    (add-hook 'completion-at-point-functions #'cape-file)
    (add-hook 'completion-at-point-functions #'cape-elisp-block))
#+end_src
** Completions

#+begin_src emacs-lisp :tangle "post-init.el"

  (use-package vertico
    ;; (Note: It is recommended to also enable the savehist package.)
    :ensure t
    ;; :demand t
    :commands vertico-mode
    ;; :init (vertico-mode 1)
    :hook (elpaca-after-init . vertico-mode))

  (use-package orderless
    ;; Vertico leverages Orderless' flexible matching capabilities, allowing users
    ;; to input multiple patterns separated by spaces, which Orderless then
    ;; matches in any order against the candidates.
    :ensure t
    :custom
    (completion-styles '(orderless basic))
    (completion-category-defaults nil)
    (completion-category-overrides '((file (styles partial-completion)))))

  (use-package marginalia
    ;; Marginalia allows Embark to offer you preconfigured actions in more contexts.
    ;; In addition to that, Marginalia also enhances Vertico by adding rich
    ;; annotations to the completion candidates displayed in Vertico's interface.
    :ensure t
    ;; :demand t
    :commands (marginalia-mode marginalia-cycle)
    ;; :init (marginalia-mode 1)
    :hook (elpaca-after-init . marginalia-mode))
  ;; :hook (after-init . marginalia-mode)

  (use-package embark
    ;; Embark is an Emacs package that acts like a context menu, allowing
    ;; users to perform context-sensitive actions on selected items
    ;; directly from the completion interface.
    :ensure t
    :defer t
    :commands (embark-act
               embark-dwim
               embark-export
               embark-collect
               embark-bindings
               embark-prefix-help-command)
    :bind
    (("C-." . embark-act)         ;; pick some comfortable binding
     ("C-;" . embark-dwim)        ;; good alternative: M-.
     ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

    :init
    (setq prefix-help-command #'embark-prefix-help-command)

    :config
    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none)))))

  (use-package embark-consult
    :ensure t
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))

  (use-package consult
    :ensure t
    :bind (;; C-c bindings in `mode-specific-map'
           ("C-c M-x" . consult-mode-command)
           ("C-c h" . consult-history)
           ("C-c k" . consult-kmacro)
           ("C-c M" . consult-man)
           ("C-c I" . consult-info)
           ([remap Info-search] . consult-info)
           ;; C-x bindings in `ctl-x-map'
           ("C-x M-:" . consult-complex-command)
           ("C-x b" . consult-buffer)
           ("C-x 4 b" . consult-buffer-other-window)
           ("C-x 5 b" . consult-buffer-other-frame)
           ("C-x t b" . consult-buffer-other-tab)
           ("C-x r b" . consult-bookmark)
           ("C-x p b" . consult-project-buffer)
           ;; Custom M-# bindings for fast register access
           ("M-#" . consult-register-load)
           ("M-'" . consult-register-store)
           ("C-M-#" . consult-register)
           ;; Other custom bindings
           ("M-y" . consult-yank-pop)
           ("C-c C-x C-<tab>" . my/consult-clock-in)
           ;; M-g bindings in `goto-map'
           ("M-g e" . consult-compile-error)
           ("M-g f" . consult-flymake)
           ("M-g g" . consult-goto-line)
           ("M-g M-g" . consult-goto-line)
           ("M-g o" . consult-outline)
           ("M-g t" . consult-org-agenda)
           ("M-g m" . consult-mark)
           ("M-g k" . consult-global-mark)
           ("M-g i" . consult-imenu)
           ("M-g I" . consult-imenu-multi)
           ;; M-s bindings in `search-map'
           ("M-s d" . consult-find)
           ("M-s c" . consult-locate)
           ("M-s g" . consult-grep)
           ("M-s G" . consult-git-grep)
           ("M-s r" . consult-ripgrep)
           ("M-s l" . consult-line)
           ("M-s L" . consult-line-multi)
           ("M-s k" . consult-keep-lines)
           ("M-s u" . consult-focus-lines)
           ;; Isearch integration
           ("M-s e" . consult-isearch-history)
           :map isearch-mode-map
           ("M-e" . consult-isearch-history)
           ("M-s e" . consult-isearch-history)
           ("M-s l" . consult-line)
           ("M-s L" . consult-line-multi)
           ;; Minibuffer history
           :map minibuffer-local-map
           ("M-s" . consult-history)
           ("M-r" . consult-history))

    ;; Enable automatic preview at point in the *Completions* buffer.
    :hook (completion-list-mode . consult-preview-at-point-mode)

    :init
    ;; Optionally configure the register formatting. This improves the register
    (setq register-preview-delay 0.5
          register-preview-function #'consult-register-format)

    ;; Optionally tweak the register preview window.
    (advice-add #'register-preview :override #'consult-register-window)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)

    (defun my/consult-clock-in ()
      "Use consult-org-agenda to select and clock into a task without changing current buffer."
      (interactive)
      (let ((original-buffer (current-buffer)))
        (when-let (marker (consult-org-agenda))
          (org-with-point-at marker
            (org-clock-in)))
        (switch-to-buffer original-buffer)))

    :config
    (consult-customize
     consult-theme :preview-key '(:debounce 0.2 any)
     consult-ripgrep consult-git-grep consult-grep
     consult-bookmark consult-recent-file consult-xref
     consult--source-bookmark consult--source-file-register
     consult--source-recent-file consult--source-project-recent-file
     ;; :preview-key "M-."
     :preview-key '(:debounce 0.4 any))
    (setq consult-narrow-key "<"))

#+end_src
** Code Folding
#+begin_src emacs-lisp :tangle "post-init.el"
  (use-package outline-indent
    :ensure t
    :defer t
    :commands outline-indent-minor-mode

    :init
    ;; The minor mode can also be automatically activated for a certain modes.
    ;; For example for Python and YAML:
    (add-hook 'python-mode-hook #'outline-indent-minor-mode)
    (add-hook 'python-ts-mode-hook #'outline-indent-minor-mode)

    (add-hook 'yaml-mode-hook #'outline-indent-minor-mode)
    (add-hook 'yaml-ts-mode-hook #'outline-indent-minor-mode)

    :custom
    (outline-indent-ellipsis " ▼ "))
#+end_src
** Enhanced undo/redo
#+begin_src emacs-lisp :tangle "post-init.el"
  ;; The undo-fu package is a lightweight wrapper around Emacs' built-in undo
  ;; system, providing more convenient undo/redo functionality.
  (use-package undo-fu
    :commands (undo-fu-only-undo
               undo-fu-only-redo
               undo-fu-only-redo-all
               undo-fu-disable-checkpoint)
    :bind (("C-z" . nil)
           ("C-z" . undo-fu-only-undo)
           ("C-S-z" . undo-fu-only-redo))
    )

  ;; The undo-fu-session package complements undo-fu by enabling the saving
  ;; and restoration of undo history across Emacs sessions, even after restarting.
  (use-package undo-fu-session
    :defer t
    :commands undo-fu-session-global-mode
    :hook (after-init . undo-fu-session-global-mode))
#+end_src
** COMMENT Evil

#+begin_src emacs-lisp :tangle "post-init.el"

  ;; evil-want-keybinding must be declared before Evil and Evil Collection
  (setq evil-want-keybinding nil)

  (use-package evil
    :ensure t
    :init
    (setq evil-undo-system 'undo-fu)
    (setq evil-want-integration t)
    (setq evil-want-keybinding nil)

    (setq evil-respect-visual-line-mode t)
    (setq evil-undo-system 'undo-fu)

    ;; Prevents esc-key from translating to meta-key in terminal mode.
    (setq evil-esc-delay 0)
    (setq-default evil-shift-width 2)
    (setq-default evil-symbol-word-search t)

    (with-eval-after-load "org"
      (evil-add-command-properties #'org-open-at-point :jump t))

    :custom
    (evil-want-Y-yank-to-eol t)
    :config
    (evil-declare-key 'normal org-mode-map
                      "gk" 'outline-up-heading
                      "gj" 'outline-next-visible-heading
                      "H" 'org-beginning-of-line
                      "L" 'org-end-of-line
                      "t" 'org-todo
                      (kbd "<tab>") 'org-cycle
                      ",c" 'org-cycle
                      ",e" 'org-export-dispatch
                      ",n" 'outline-next-visible-heading
                      ",p" 'outline-previous-visible-heading
                      ",t" 'org-set-tags-command
                      ",u" 'outline-up-heading
                      "$" 'org-end-of-line
                      "^" 'org-beginning-of-line
                      "-" 'org-ctrl-c-minus ; change bullet style
                      )

    (evil-select-search-module 'evil-search-module 'evil-search)
    (evil-mode 1))

  (use-package evil-collection
    :after evil ;; mu4e
    :ensure t
    :config
    (evil-collection-init))

  (use-package evil-org
    :ensure t
    :after org
    :hook (org-mode . (lambda () evil-org-mode))
    :config
    (require 'evil-org-agenda)
    (evil-org-agenda-set-keys))

  ;;  (use-package vim-tab-bar
  ;;    :ensure t
  ;;    :commands vim-tab-bar-mode
  ;;    :hook (after-init . vim-tab-bar-mode))

  (use-package evil-visualstar
    :after evil
    :ensure t
    :defer t
    :commands global-evil-visualstar-mode
    :hook (after-init . global-evil-visualstar-mode))

  (use-package evil-surround
    :after evil
    :ensure t
    :defer t
    :commands global-evil-surround-mode
    :custom
    (evil-surround-pairs-alist
     '((?\( . ("(" . ")"))
       (?\[ . ("[" . "]"))
       (?\{ . ("{" . "}"))

       (?\) . ("(" . ")"))
       (?\] . ("[" . "]"))
       (?\} . ("{" . "}"))

       (?< . ("<" . ">"))
       (?> . ("<" . ">"))))
    :hook (after-init . global-evil-surround-mode))

  (with-eval-after-load "evil"
    (evil-define-operator my-evil-comment-or-uncomment (beg end)
                          "Toggle comment for the region between BEG and END."
                          (interactive "<r>")
                          (comment-or-uncomment-region beg end))
    (evil-define-key 'normal 'global (kbd "gc") 'my-evil-comment-or-uncomment))

  (use-package evil-snipe
    :defer t
    :commands evil-snipe-mode
    :init (evil-snipe-mode 1))
  ;; :hook (after-init . evil-snipe-mode))
#+end_src
** Modeline
#+begin_src emacs-lisp :tangle "post-init.el"
  (use-package diminish
    :config (require 'diminish))
  (use-package timu-line
    :disabled
    :ensure t
    :demand t
    :config
    (timu-line-mode 1))
  (use-package all-the-icons)
  ;; (use-package nerd-icons)
  (use-package doom-modeline
    :ensure (:host github :repo "seagle0128/doom-modeline")
    :demand
    :init
    (doom-modeline-mode 1)
    :custom
    (doom-modeline-enable-word-count t)
    (doom-modeline-buffer-encoding nil)
    (doom-modeline-time-icon nil)
    (doom-modeline-minor-modes t))
  ;; (use-package hide-mode-line :demand t) - replaced with built-in mode-line-invisible-mode (emacs 31)
  (use-package nano-modeline
    :disabled
    :demand
    :config
    (setopt mode-line-format nil)
    (nano-modeline-text-mode t)
    (add-hook 'prog-mode-hook            #'nano-modeline-prog-mode)
    (add-hook 'text-mode-hook            #'nano-modeline-text-mode)
    (add-hook 'org-mode-hook             #'nano-modeline-org-mode)
    (add-hook 'pdf-view-mode-hook        #'nano-modeline-pdf-mode)
    (add-hook 'mu4e-headers-mode-hook    #'nano-modeline-mu4e-headers-mode)
    (add-hook 'mu4e-view-mode-hook       #'nano-modeline-mu4e-message-mode)
    (add-hook 'mu4e-compose-mode-hook    #'nano-modeline-mu4e-compose-mode)
    (add-hook 'elfeed-show-mode-hook     #'nano-modeline-elfeed-entry-mode)
    (add-hook 'elfeed-search-mode-hook   #'nano-modeline-elfeed-search-mode)
    ;; (add-hook 'elpher-mode-hook          #'nano-modeline-elpher-mode)
    (add-hook 'term-mode-hook            #'nano-modeline-term-mode)
    (add-hook 'eat-mode-hook             #'nano-modeline-eat-mode)
    (add-hook 'xwidget-webkit-mode-hook  #'nano-modeline-xwidget-mode)
    (add-hook 'messages-buffer-mode-hook #'nano-modeline-message-mode)
    (add-hook 'org-capture-mode-hook     #'nano-modeline-org-capture-mode)
    (add-hook 'org-agenda-mode-hook      #'nano-modeline-org-agenda-mode)
    )

#+end_src
** Dirvish
#+begin_src emacs-lisp :tangle "post-init.el"
  (use-package dirvish
    :init
    (dirvish-override-dired-mode)
    :custom
    (dirvish-quick-access-entries ; It's a custom option, `setq' won't work
     '(("h" "~/"                          "Home")
       ("d" "~/Downloads/"                "Downloads")
       ("n" "~/ndxrd-uxxs3/notes/"        "Notes")
       ("o" "~/ndxrd-uxxs3/org/"          "GTD Org")
       ("c" "~/.emacs.d/"         "Config")))
    :config
    ;; (dirvish-peek-mode) ; Preview files in minibuffer
    ;; (dirvish-side-follow-mode) ; similar to `treemacs-follow-mode'
    (setq dirvish-mode-line-format
          '(:left (sort symlink) :right (omit yank index)))
    (setq dirvish-attributes
          '(all-the-icons file-time file-size collapse subtree-state vc-state git-msg))
    (setq delete-by-moving-to-trash t)
    (setq dired-listing-switches
          "-l --almost-all --human-readable --group-directories-first --no-group")
    ;; (evil-make-overriding-map dirvish-mode-map 'normal)
    :bind ; Bind `dirvish|dirvish-side|dirvish-dwim' as you see fit
    (("C-c f" . dirvish)
     :map dirvish-mode-map ; Dirvish inherits `dired-mode-map'
     ("a"   . dirvish-quick-access)
     ("f"   . dirvish-file-info-menu)
     ("y"   . dirvish-yank-menu)
     ("N"   . dirvish-narrow)
     ("^"   . dirvish-history-last)
     ("h"   . dirvish-history-jump) ; remapped `describe-mode'
     ("s"   . dirvish-quicksort)    ; remapped `dired-sort-toggle-or-edit'
     ("v"   . dirvish-vc-menu)      ; remapped `dired-view-file'
     ("TAB" . dirvish-subtree-toggle)
     ("M-f" . dirvish-history-go-forward)
     ("M-b" . dirvish-history-go-backward)
     ("M-l" . dirvish-ls-switches-menu)
     ("M-m" . dirvish-mark-menu)
     ("M-t" . dirvish-layout-toggle)
     ("M-s" . dirvish-setup-menu)
     ("M-e" . dirvish-emerge-menu)
     ("M-j" . dirvish-fd-jump)))
#+end_src
** COMMENT Elpaca Sync
#+begin_src emacs-lisp :tangle "post-init.el"
  (elpaca-process-queues)
#+end_src
** Shell and Terminals
#+begin_src emacs-lisp :tangle "post-init.el"
  ;; (defun bb/setup-term-mode ()
  ;;   (evil-local-set-key 'insert (kbd "C-r") 'bb/send-C-r))

  (defun bb/send-C-r ()
    (interactive)
    (term-send-raw-string "\C-r"))

  ;; (add-hook 'term-mode-hook 'bb/setup-term-mode)

  (when (or my-linux-p my-mac-p)
    (use-package multi-term)
    (use-package eat)
    (use-package vterm
      :config
      (setopt vterm-buffer-name-string "vterm/%s")
      )
    (use-package multi-vterm)
    (use-package eshell-atuin
      :after eshell
      :demand t
      :bind (:map eshell-hist-mode-map ("M-r" . eshell-atuin-history))
      :init
      (require 'em-hist)
      :config
      (eshell-atuin-mode)
      (setq eshell-atuin-search-fields '(time duration command))
      (setq eshell-atuin-history-format "%-160c %t + %d")
      )
    )

  (when my-windows-p
    (use-package powershell))

  (use-package dwim-shell-command
    :demand t
    :bind (([remap shell-command] . dwim-shell-command)
           :map dired-mode-map
           ([remap dired-do-async-shell-command] . dwim-shell-command)
           ([remap dired-do-shell-command] . dwim-shell-command)
           ([remap dired-smart-shell-command] . dwim-shell-command))
    :config
    (require 'proced)
    (defun dwim-shell-commands-kill-process ()
      "Select and kill process."
      (interactive)
      (let* ((pid-width 5)
             (comm-width 25)
             (user-width 10)
             (processes (proced-process-attributes))
             (candidates
              (mapcar (lambda (attributes)
                        (let* ((process (cdr attributes))
                               (pid (format (format "%%%ds" pid-width) (map-elt process 'pid)))
                               (user (format (format "%%-%ds" user-width)
                                             (truncate-string-to-width
                                              (map-elt process 'user) user-width nil nil t)))
                               (comm (format (format "%%-%ds" comm-width)
                                             (truncate-string-to-width
                                              (map-elt process 'comm) comm-width nil nil t)))
                               (args-width (- (window-width) (+ pid-width user-width comm-width 3)))
                               (args (map-elt process 'args)))
                          (cons (if args
                                    (format "%s %s %s %s" pid user comm (truncate-string-to-width args args-width nil nil t))
                                  (format "%s %s %s" pid user comm))
                                process)))
                      processes))
             (selection (map-elt candidates
                                 (completing-read "kill process: "
                                                  (seq-sort
                                                   (lambda (p1 p2)
                                                     (string-lessp (nth 2 (split-string (string-trim (car p1))))
                                                                   (nth 2 (split-string (string-trim (car p2))))))
                                                   candidates) nil t)))
             (prompt-title (format "%s %s %s"
                                   (map-elt selection 'pid)
                                   (map-elt selection 'user)
                                   (map-elt selection 'comm))))
        (when (y-or-n-p (format "Kill %s?" prompt-title))
          (dwim-shell-command-on-marked-files
           (format "Kill %s" prompt-title)
           (format "kill -9 %d" (map-elt selection 'pid))
           :utils "kill"
           :error-autofocus t
           :silent-success t))))
    )

#+end_src
** Authentication and Passwords
I'm using 1password for all passwords.

But, I'm not satisfied, because this starts a 1password auth prompt window for each different password asked. Ideal workflow would be to ask for password or fingerprint once at the beginning (or on first use) and then cache it as long as the Emacs session is active (or only forget if it the OS is locked).

One alternative can be to have a separate script to copy the required passwords from 1password to authinfo.gpg and use authinfo.gpg

#+begin_src emacs-lisp :tangle "post-init.el"
  (use-package auth-source-1password
    :if (not my-phone-p)
    :demand t
    :config
    (auth-source-1password-enable))
#+end_src
** Org
#+begin_src emacs-lisp :tangle "post-init.el"
  (use-package org
    :ensure nil
    :demand t
    :hook (;; (elpaca-after-init . org-mode)
           (org-capture-mode . delete-other-windows)
           )
    :bind
    ("C-c i" . org-capture-inbox)
    ("C-c j" . org-open-inbox)
    ("C-c a" . org-agenda)
    ("C-c l" . org-store-link)

    :custom

    ;; Visual and behavior changes
    (org-support-shift-select t)
    ;; (org-ellipsis " ▼")
    (org-ellipsis "…")

    (org-agenda-start-with-log-mode t)
    (org-agenda-log-mode-items '(clock))
    (org-agenda-window-setup 'only-window)

    (org-startup-folded 'content)
    (org-startup-indented t)
    (org-startup-with-inline-images t)

    (org-auto-align-tags nil)
    (org-tags-column 0)
    (org-catch-invisible-edits 'show-and-error)
    (org-special-ctrl-a/e t)
    (org-insert-heading-respect-content t)
    (org-hide-emphasis-markers t)
    (org-pretty-entities t)
    (org-agenda-tags-column 0)
    

    :config

    ;; Files
    (setopt org-directory "~/ndxrd-uxxs3/org")
    (setopt org-agenda-files (list "inbox.org" "calendar.org" "tickler.org"
                                   "personal.org" "work.org"))

    ;; Capture
    (setopt org-capture-templates
            `(("i" "Inbox" entry  (file "inbox.org") "* %?\n%U\n%i")
              ("l" "Inbox [mail]" entry (file "inbox.org") "* %?\n%U\n%i\n%a")))

    (defun org-capture-inbox ()
      (interactive)
      (org-capture nil "i"))

    (defun org-capture-mail ()
      (interactive)
      (call-interactively 'org-store-link)
      (org-capture nil "l"))

    (defun org-open-inbox ()
      (interactive)
      (find-file "~/ndxrd-uxxs3/org/inbox.org")
      )

    ;; Use full window for org-capture
    (add-hook 'org-capture-mode-hook 'delete-other-windows)

    ;; Refile
    (setopt org-refile-use-outline-path t)
    (setopt org-outline-path-complete-in-steps nil)
    (setq org-refile-targets
          '((("work.org" "personal.org") :maxlevel . 3)))

    (setq org-refile-target-verify-function
          (lambda ()
            (let ((props (org-entry-properties)))
              (or
               ;; Allow level 1 headings with ORG_GTD property (Actions, Projects, Incubated)
               (and (= (org-current-level) 1)
                    (assoc "ORG_GTD" props))
               ;; Allow level 2+ headings under Projects sections
               (and (> (org-current-level) 1)
                    (save-excursion
                      (org-up-heading-safe)
                      (string= "Projects" (cdr (assoc "ORG_GTD" (org-entry-properties))))))))))

    (advice-add 'org-refile :after
                (lambda (&rest _)
                  (org-save-all-org-buffers)))

    ;; Keywords and their workflows
    (setopt org-todo-keywords
            '((sequence "NEXT(n)" "TODO(t)" "WAIT(w@)" "|" "DONE(d)" "CNCL(c@)")))
    (setopt org-log-done 'time)

    ;; Tags
    ;; (setopt org-tag-persistent-alist '((:startgroup . nil)
    ;;                                    ("@computer") ("@mail") ("@errands") ("@calls") ("@meetings")
    ;;                                    (:endgroup . nil) (:startgroup . nil)
    ;;                                    ("@tz-ist") ("@tz-est") ("@anytime")
    ;;                                    (:endgroup . nil)
    ;;                                    ("@fun") ("@agenda") ("@home") ("@anywhere")
    ;;                                    ))
    (setopt org-tag-persistent-alist
            '((:startgroup . nil)
              ("@office" . ?o)
              ("@home" . ?h)
              ("@computer" . ?c)
              ("@phone" . ?p)
              ("@errands" . ?e)
              (:endgroup . nil)
              ("@waiting" . ?w)
              ("@1on1s" . ?1)
              ("@deep" . ?d)
              ("@shallow" . ?s)))

    (defvar my/gtd-context-tags '("@office" "@home" "@computer" "@phone" "@errands" "@waiting" "@1on1s" "@deep" "@shallow")
      "Valid GTD context tags.")

    (defun my/skip-if-has-context ()
      "Skip entry if it has any valid context tag."
      (let ((tags (org-get-tags)))
        (when (cl-intersection tags my/gtd-context-tags :test #'string=)
          (org-entry-end-position))))

    (defun my/skip-if-missing-context ()
      "Skip entry if it has no valid context tag."
      (let ((tags (org-get-tags)))
        (unless (cl-intersection tags my/gtd-context-tags :test #'string=)
          (org-entry-end-position))))

    ;; Agenda
    (setopt org-agenda-custom-commands
            '(("g" "Get Things Done (GTD)"
               ((agenda ""
                        ((org-agenda-span 1)
                         (org-deadline-warning-days 0)))
                (todo "NEXT"
                      ((org-agenda-skip-function
                        '(org-agenda-skip-entry-if 'deadline))
                       (org-agenda-prefix-format "    ")
                       ;; (org-agenda-prefix-format "  [%5e] ")
                       (org-agenda-overriding-header "\nNext Actions\n")))
                (todo "WAIT"
                      ((org-agenda-skip-function
                        '(org-agenda-skip-entry-if 'deadline))
                       (org-agenda-prefix-format "    ")
                       (org-agenda-overriding-header "\nWaiting Fors\n")))
                (search "*"
                        ((org-agenda-prefix-format "  %?-12t% s")
                         (org-agenda-files (list (expand-file-name "inbox.org" org-directory)))
                         (org-agenda-overriding-header "\nInbox\n")))
                (tags "CLOSED>=\"<today>\""
                      ((org-agenda-prefix-format "    ")
                       (org-agenda-overriding-header "\nCompleted today\n")))))
              ("c" . "Contexts")
              ("cc" "Computer" tags-todo "@computer/NEXT"
               ((org-agenda-overriding-header "\nComputer - Next Actions\n")))
              ("co" "Office" tags-todo "@office/NEXT"
               ((org-agenda-overriding-header "\nOffice - Next Actions\n")))
              ("ch" "Home" tags-todo "@home/NEXT"
               ((org-agenda-overriding-header "\nHome - Next Actions\n")))

              ("m" . "Maintenance")
              ("mt" "Missing context" todo "NEXT"
               ((org-agenda-skip-function 'my/skip-if-has-context)
                (org-agenda-overriding-header "\nNEXT without context tag\n")))
              ))

    ;; Archival
    (defun my/org-archive-location-func ()
      "Custom function to define where to archive items."
      (let* ((year (number-to-string (caddr (calendar-current-date))))
             (full-org-directory (expand-file-name org-directory))
             (filename (format "gtd_archive_%s" year))
             (filepath (expand-file-name filename full-org-directory)))
        (string-join `(,filepath "::" "datetree/"))))
    (setopt org-archive-location (my/org-archive-location-func))

    ;; Clocking
    (setopt org-clock-persist 'history)
    (setopt org-log-into-drawer t)
    (setopt org-log-done 'time)
    (org-clock-persistence-insinuate)
    (defun current-clock-time-to-file ()
      (interactive)
      (with-temp-file "~/.local/state/task"
        (if (org-clocking-p)
            (insert (org-clock-get-clock-string))
          (insert "No Task"))))
    (run-with-timer 1 60 'current-clock-time-to-file)
    (add-hook 'org-clock-in-hook 'current-clock-time-to-file)
    (add-hook 'org-clock-out-hook 'current-clock-time-to-file)

    (when my-mac-p
      (defun my/focus-clock-in ()
        (let* ((task-name (org-get-heading t t t t))
               (file-name (file-name-sans-extension (buffer-name)))
               (profile (cond
                         ((string= task-name "Break") "break")
                         ((string= task-name "Reading") "break")
                         (t (downcase file-name))))
               (url (format "focus://focus?profile=%s" profile))
               (cmd (format "open -g '%s'" url)))
          (shell-command cmd)))

      (defun my/focus-clock-out ()
        (let* ((task-name (org-get-heading t t t t))
               (file-name (file-name-sans-extension (buffer-name)))
               (profile (cond
                         ((string= task-name "Break") "break")
                         ((string= task-name "Reading") "break")
                         (t (downcase file-name))))
               (url (format "focus://unfocus?profile=%s" profile))
               (cmd (format "open -g '%s'" url)))
          (shell-command cmd)))

      ;;(add-hook 'org-clock-in-hook #'my/focus-clock-in)
      ;;(add-hook 'org-clock-out-hook #'my/focus-clock-out)
      )

    )

  (use-package org-protocol
    :ensure nil
    :after org
    :demand t
    :custom
    (org-protocol-default-template-key "l")
    )

  (use-package org-edna
    :demand t
    :after org
    :config
    (setopt org-edna-use-inheritance t)
    (org-edna-mode 1))

  (use-package org-modern
    :after org
    :demand t
    :config
    (global-org-modern-mode 1)
    )

#+end_src
** COMMENT Org and GTD (Old)
#+begin_src emacs-lisp :tangle "post-init.el"
  (use-package org
    :ensure nil
    :hook ((elpaca-after-init . org-mode)
           (org-capture-mode . delete-other-windows)
           ;; (org-capture-mode . evil-insert-state)
           )
    :custom
    (org-support-shift-select t)
    (org-agenda-files nil) ;; Will be set automatically by org-gtd
    (org-ellipsis " ▼")
    (org-cycle-separator-lines 1)
    ;; (org-pretty-entities t)

    (org-agenda-start-with-log-mode t)
    (org-agenda-window-setup 'only-window)
    (org-startup-folded 'content)
    (org-startup-indented t)
    (org-startup-with-inline-images t)
    (org-clock-persist 'history)
    (org-log-into-drawer t)
    (org-log-done 'time)
    (org-tag-persistent-alist '((:startgroup . nil)
                                ("@computer") ("@mail") ("@errands") ("@calls") ("@meetings")
                                (:endgroup . nil) (:startgroup . nil)
                                ("@tz-ist") ("@tz-est") ("@anytime")
                                (:endgroup . nil)
                                ("@fun") ("@agenda") ("@home") ("@anywhere")
                                ))
    (org-capture-templates
     '(
       ("i" "Inbox" entry (file org-gtd-inbox-path) "* %?\n%U\n%i"
        :kill-buffer t)
       ("l" "Inbox with link" entry (file org-gtd-inbox-path) "* %?\n%U\n%i\n%a"
        :kill-buffer t)))
    :config
    (require 'org-tempo)
    ;; (setq org-agenda-prefix-format '((agenda . " %i %-12:c%?-12t%-6e% s")))
    ;; So that we can jump back
    ;; (advice-add 'org-open-at-point :before #'evil-set-jump)

    ;; Custom functions
    (defun org-capture-inbox ()
      (interactive)
      (call-interactively 'org-store-link)
      (org-gtd-capture nil "i"))
    (defun org-capture-mail ()
      (interactive)
      (call-interactively 'org-store-link)
      (org-capture nil "@"))
    (defun org-open-inbox ()
      (interactive)
      (find-file "~/ndxrd-uxxs3/org/inbox.org")
      )
    :bind
    ("C-c i" . org-capture-inbox)
    ("C-c j" . org-open-inbox)
    ("C-c a" . org-agenda)
    ("C-c l" . org-store-link)
    (:map org-mode-map
          ("C-c ;" . nil))
    )
#+END_SRC
#+begin_src emacs-lisp :tangle "post-init.el"
  (defun my/org-gtd-maybe-set-tags ()
    "Use as a hook when decorating items after clarifying them."
    (unless (org-gtd-organize-type-member-p '(trash knowledge quick-action incubated project-heading))
      (org-set-tags-command)))
  (defun my/org-gtd-maybe-set-effort ()
    "Use as a hook when decorating items after clarifying them."
    (unless (org-gtd-organize-type-member-p '(trash knowledge quick-action incubated project-heading))
      (org-set-effort)))

  (use-package org-contrib
    :defer t
    ;; :config
    ;; (require 'ox-confluence)
    )

  (defun my-org-gtd-archive-item-at-point ()
    "Dirty hack to force archiving where I know I can."
    (interactive)
    (with-temp-message ""
      (let* ((last-command nil)
             (temp-file (make-temp-file org-gtd-directory nil ".org"))
             (buffer (find-file-noselect temp-file)))
        (org-cut-subtree)
        (org-gtd-core-prepare-buffer buffer)
        (with-current-buffer buffer
          (org-paste-subtree)
          (goto-char (point-min))
          (with-org-gtd-context (org-archive-subtree-default))
          (basic-save-buffer)
          (kill-buffer))
        (delete-file temp-file))))

  (use-package org-gtd
    ;; :straight (:type git :host github :repo "Trevoke/org-gtd.el")
    :after org
    ;; :ensure t
    :demand t
    :init
    (setq org-gtd-update-ack "3.0.0")
    (setq org-gtd-areas-of-focus '("Work Leadership" "Work Architecture" "Work Support"
                                   "Productivity" "Personal Development" "Personal Services"
                                   "Family" "Health" "Finances"))
    :custom
    (org-gtd-directory "~/ndxrd-uxxs3/org/")
    (org-edna-use-inheritance t)
    (org-gtd-organize-hooks '(org-gtd-areas-of-focus--set my/org-gtd-maybe-set-tags my/org-gtd-maybe-set-effort))
    (org-gtd-refile-to-any-target nil)
    (org-gtd-engage-prefix-width 24)
    (org-gtd-capture-templates org-capture-templates)
    :config
    (org-edna-mode 1)
    (org-gtd-mode 1)
    :bind
    (("C-c d c" . org-gtd-capture)
     ("C-c c"   . org-gtd-capture)
     ("C-c d e" . org-gtd-engage)
     ("C-c d p" . org-gtd-process-inbox)
     ("C-c d n" . org-gtd-show-all-next)
     ("C-c d x" . org-gtd-clarify-item)
     ("C-c d w" . org-gtd-delegate-item-at-point)
     ("C-c d a" . org-gtd-area-of-focus-set-on-item-at-point)
     ("C-c d s" . org-save-all-org-buffers)
     ("C-c d k" . my-org-gtd-archive-item-at-point)
     :map org-gtd-clarify-map
     ("C-c c" . org-gtd-organize)
     :map org-agenda-mode-map
     ("C-c d a" . org-gtd-area-of-focus-set-on-agenda-item)
     ("C-c d x" . org-gtd-clarify-agenda-item)
     ))

#+END_SRC
** Calendar
#+begin_src emacs-lisp :tangle "post-init.el"
  (setq safe-local-variable-values
        (quote
         ((buffer-read-only . 1))))
  (use-package khalel
    :ensure (:host gitlab :repo "hperrey/khalel" :branch "master")
    :after org
    :demand t
    :config
    (setq khalel-import-org-file (expand-file-name "calendar.org" org-directory))
    (setq khalel-import-org-file-confirm-overwrite nil)
    (setq khalel-import-start-date "-3d")
    (setq khalel-import-end-date "+3d")
    (setq khalel-vdirsyncer-command "vdirsyncer")
    (setq khalel-vdirsyncer-extra-options "-verror")
    (setq khalel-import-format
          (concat "* Calendar: {title} {cancelled}{partstat-symbol}\n"
                  ;; "SCHEDULED: <{start-date-long} {start-time}>--<{end-date-long} {end-time}>\n"
                  ":PROPERTIES:\n:CALENDAR: {calendar}\n:LOCATION: {location}\n:ID: {uid}\n:END:\n"
                  "- When: <{start-date-long} {start-time}>--<{end-date-long} {end-time}>\n"
                  "- Where: {location}\n"
                  "- Description: {description}\n"
                  "- URL: {url}\n"
                  "- Organizer: {organizer}\n"))
    (setq khalel-import-org-file-header
          (concat
           ;; "# -*- org-scheduled-past-days: 0; -*-\n"
           "#+TITLE: calendar\n"
           "#+COLUMNS: %ITEM %TIMESTAMP %LOCATION %CALENDAR\n"
           "#+FILETAGS: :@calendar: \n\n"
           "*NOTE*: this file has been generated by [[elisp:(khalel-import-events)][khalel-import-events]] and "
           "/any changes to this document will be lost on the next import/!\n\n"
           "You can use [[elisp:(khalel-run-vdirsyncer)][khalel-run-vdirsyncer]] to synchronize with remote calendars.\n\n"
           "Consider adding this file to your list of agenda files so that events show up there.\n\n")))

  (defun my/org-calendar-html-to-text ()
    "Convert HTML in the first line of the Description field to plain text using pandoc."
    (interactive)
    (save-excursion
      (org-back-to-heading t)
      (let ((end (save-excursion (org-end-of-subtree t t))))
        (when (re-search-forward "^[[:space:]]*- Description: " end t)
          (let ((first-line-start (point))
                (first-line-end (line-end-position)))
            (let ((first-line-content (buffer-substring-no-properties first-line-start first-line-end)))
              (when (string-match-p "<[^>]+>" first-line-content)
                (let ((plain-text (with-temp-buffer
                                    (insert first-line-content)
                                    (shell-command-on-region
                                     (point-min) (point-max)
                                     "pandoc -f html -t plain --wrap=none"
                                     t t)
                                    (string-trim (buffer-string)))))
                  (delete-region first-line-start first-line-end)
                  (insert plain-text)
                  (message "Converted HTML to plain text in first line")))))))))

  (defun my/copy-calendar-task-to-inbox (orig-fun &rest args)
    "Copy task from calendar.org to inbox.org before clocking in"
    (let* ((marker (org-get-at-bol 'org-marker))
           (file-name (if marker
                          (buffer-file-name (marker-buffer marker))
                        (buffer-file-name)))
           (calendar-file (expand-file-name "calendar.org" org-directory))
           (inbox-file (expand-file-name "inbox.org" org-directory)))
      (if (and file-name
               (string= file-name calendar-file))
          (save-excursion
            (when marker
              (org-goto-marker-or-bmk marker))
            (let* ((task-title (org-get-heading t t t t))
                   (task-body (org-get-entry))
                   (inbox-buffer (find-file-noselect inbox-file)))
              (with-current-buffer inbox-buffer
                (let ((original-point (point-max)))
                  (goto-char original-point)
                  (insert "\n* " task-title "\n" task-body)
                  (my/org-calendar-html-to-text)
                  (save-buffer)
                  (goto-char original-point)
                  (forward-line 1)
                  (apply orig-fun args)))))
        ;; If not in calendar.org, just run the original function
        (apply orig-fun args))))

  (advice-add 'org-clock-in :around #'my/copy-calendar-task-to-inbox)

  (defun my/complete-calendar-task ()
    "Copy current calendar task to inbox.org, add logbook entry, and mark done."
    (interactive)
    (let* ((calendar-file (expand-file-name "calendar.org" org-directory))
           (inbox-file (expand-file-name "inbox.org" org-directory))
           (marker (or (org-get-at-bol 'org-marker) (point-marker)))
           (source-file (if marker
                            (buffer-file-name (marker-buffer marker))
                          (buffer-file-name))))
      
      ;; Check if the task is from calendar.org
      (unless (and source-file (string= source-file calendar-file))
        (error "This function should be called on tasks from calendar.org"))
      
      ;; Work with the task at the marker position
      (with-current-buffer (marker-buffer marker)
        (save-excursion
          (goto-char marker)
          (org-back-to-heading t)
          
          ;; Get task information - but limit to current entry only
          (let* ((task-title (org-get-heading t t t t))
                 (entry-start (point))
                 (entry-end (save-excursion (org-end-of-subtree t t)))
                 ;; Extract start and end times from THIS entry only
                 (when-line (save-excursion
                              (goto-char entry-start)
                              (if (re-search-forward "- When: \\(<.*?>\\)--\\(<.*?>\\)" entry-end t)
                                  (list (match-string 1) (match-string 2))
                                nil))))
            
            (unless when-line
              (error "Could not find start and end times in this task"))
            
            (let* ((start-time-angular (car when-line))
                   (end-time-angular (cadr when-line))
                   ;; Convert angular brackets to square brackets for CLOCK entries
                   (start-time-square (replace-regexp-in-string "<\\|>" (lambda (match) (if (string= match "<") "[" "]")) start-time-angular))
                   (end-time-square (replace-regexp-in-string "<\\|>" (lambda (match) (if (string= match "<") "[" "]")) end-time-angular))
                   ;; Calculate duration
                   (start-time (org-parse-time-string start-time-angular))
                   (end-time (org-parse-time-string end-time-angular))
                   (start-seconds (+ (* (nth 2 start-time) 3600) (* (nth 1 start-time) 60)))
                   (end-seconds (+ (* (nth 2 end-time) 3600) (* (nth 1 end-time) 60)))
                   (duration-seconds (- end-seconds start-seconds))
                   (duration-hours (/ duration-seconds 3600))
                   (duration-minutes (/ (% duration-seconds 3600) 60))
                   (duration-string (format "%d:%02d" duration-hours duration-minutes)))
              
              ;; Parse the entry content more carefully
              (goto-char entry-start)
              (forward-line 1) ;; Skip the heading
              (let* ((content-start (point))
                     (properties-start (and (re-search-forward "^:PROPERTIES:$" entry-end t)
                                            (line-beginning-position)))
                     (properties-end (and properties-start
                                          (re-search-forward "^:END:$" entry-end t)
                                          (line-end-position)))
                     (properties-content (and properties-start properties-end
                                              (buffer-substring-no-properties properties-start properties-end)))
                     (remaining-content (and properties-end
                                             (buffer-substring-no-properties (1+ properties-end) entry-end)))
                     ;; Convert angular brackets to square brackets only on "- When:" lines
                     (remaining-content-fixed (and remaining-content
                                                   (replace-regexp-in-string 
                                                    "^- When: <\\([^>]+\\)>--<\\([^>]+\\)>$"
                                                    "- When: [\\1]--[\\2]"
                                                    remaining-content nil nil nil))))
                
                ;; Copy task to inbox.org
                (with-current-buffer (find-file-noselect inbox-file)
                  (goto-char (point-max))
                  (insert "\n* DONE " task-title "\n")
                  ;; Set CLOSED timestamp to match event end time
                  (insert "CLOSED: " end-time-square "\n")
                  
                  ;; Insert properties drawer if it exists
                  (when properties-content
                    (insert properties-content "\n"))
                  
                  ;; Insert logbook
                  (insert ":LOGBOOK:\n")
                  (insert "CLOCK: " start-time-square "--" end-time-square " => " duration-string "\n")
                  (insert ":END:\n")
                  
                  ;; Insert remaining content (the body after properties) with fixed When line
                  (when remaining-content-fixed
                    (insert remaining-content-fixed))

                  (my/org-calendar-html-to-text)
                  
                  ;; Save the inbox file
                  (save-buffer)
                  
                  ;; Position cursor at the new task
                  (org-back-to-heading t)))
              
              (message "Calendar task copied to inbox.org and marked as DONE with logbook entry")))))))

#+end_src
** Org in Android
#+begin_src emacs-lisp :tangle "post-init.el"
  (when my-phone-p
    ;; Clock in with task selection
    (defun toolbar-org-clock-in-smart ()
      "Smart clock in - use current heading or select task."
      (interactive)
      (cond
       ;; If already clocked in, ask to switch
       (org-clock-current-task
        (when (y-or-n-p (format "Already clocked in to '%s'. Switch tasks? " 
                                org-clock-current-task))
          (org-clock-out)
          (if (and (eq major-mode 'org-mode) (org-at-heading-p))
              (org-clock-in)
            (org-clock-in '(4))))) ; With prefix arg to select task
       ;; If on org heading, clock in directly
       ((and (eq major-mode 'org-mode) (org-at-heading-p))
        (org-clock-in))
       ;; Otherwise, let user select task
       (t
        (org-clock-in '(4)))))

    ;; Clock out with summary
    (defun toolbar-org-clock-out-with-summary ()
      "Clock out and show summary."
      (interactive)
      (when org-clock-current-task
        (let ((task org-clock-current-task)
              (duration (org-duration-from-minutes
                         (floor (org-time-convert-to-integer
                                 (time-since org-clock-start-time)) 60))))
          (org-clock-out)
          (message "Clocked out of '%s' - Duration: %s" task duration))))

    ;; Jump to currently clocked task
    (defun toolbar-org-clock-goto ()
      "Jump to currently clocked task."
      (interactive)
      (if org-clock-current-task
          (org-clock-goto)
        (message "No active clock")))

    (defun org-agenda-gtd ()
      (interactive)
      (org-agenda nil "g"))

    (setq tool-bar-map (make-sparse-keymap))
    (tool-bar-add-item "mail/inbox" 'org-open-inbox 'org-inbox-button
                       :help "Open Inbox")
    (tool-bar-add-item nil nil 'separator-1 :separator t)
    (tool-bar-add-item "index" 'org-agenda-gtd 'gtd-engage-button
                       :help "GTD Engage")
    (tool-bar-add-item "gnus/toggle-subscription" 'org-resolve-clocks 'resolve-clocks-button
                       :help "Resolve Clocks")
    (tool-bar-add-item nil nil 'separator-2 :separator t)
    (tool-bar-add-item "mpc/play" 'toolbar-org-clock-in-smart 'smart-clock-in
                       :help "Clock in to task (smart selection)")
    (tool-bar-add-item "mpc/stop" 'toolbar-org-clock-out-with-summary 'clock-out-summary
                       :help "Clock out with time summary")
    (tool-bar-add-item "jump-to" 'toolbar-org-clock-goto 'goto-clock
                       :help "Jump to currently clocked task")
    (tool-bar-add-item "save" 'org-save-all-org-buffers 'save-all-org
                       :help "Save all modified org buffers")
    )
#+end_src
** Hyperbole / Dashboard
#+begin_src emacs-lisp :tangle "post-init.el"
  (use-package hyperbole
    :demand t)

#+end_src
** Popup frames
#+begin_src emacs-lisp :tangle "post-init.el"
  ;;;; Run commands in a popup frame

  (defun prot-window-delete-popup-frame (&rest _)
    "Kill selected selected frame if it has parameter `prot-window-popup-frame`.
  Use this function via a hook."
    (when (frame-parameter nil 'prot-window-popup-frame)
      (delete-frame)))

  (defmacro prot-window-define-with-popup-frame (command)
    "Define interactive function which calls COMMAND in a new frame.
  Make the new frame have the `prot-window-popup-frame' parameter."
    `(defun ,(intern (format "prot-window-popup-%s" command)) ()
       ,(format "Run `%s' in a popup frame with `prot-window-popup-frame' parameter.
  Also see `prot-window-delete-popup-frame'." command)
       (interactive)
       (let ((frame (make-frame '((prot-window-popup-frame . t)))))
         (select-frame frame)
         (switch-to-buffer " prot-window-hidden-buffer-for-popup-frame")
         (condition-case nil
             (call-interactively ',command)
           ((quit error user-error)
            (delete-frame frame))))))

  (declare-function org-capture "org-capture" (&optional goto keys))
  (defvar org-capture-after-finalize-hook)

  ;;;###autoload (autoload 'prot-window-popup-org-capture "prot-window")
  (prot-window-define-with-popup-frame org-capture)

  (add-hook 'org-capture-after-finalize-hook #'prot-window-delete-popup-frame)

  ;; (declare-function tmr "tmr" (time &optional description acknowledgep))
  ;; (defvar tmr-timer-created-functions)

  ;;;###autoload (autoload 'prot-window-popup-tmr "prot-window")
  ;; (prot-window-define-with-popup-frame tmr)

  ;; (add-hook 'tmr-timer-created-functions #'prot-window-delete-popup-frame)C
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle "post-init.el"
  (use-package todoist :demand t)

  (defun fetch-todoist-inbox ()
    (interactive)
    (let ((tasks (todoist--query "GET" "/tasks?project_id=377175964")))
      (mapcar (lambda (task)
                (todoist--insert-task task 1 t)
                (todoist--query
                 "DELETE"
                 (format "/tasks/%s" (todoist--task-id task))))
              tasks)
      ))

#+END_SRC
** Notes
*** COMMENT Howm
#+begin_src emacs-lisp :tangle "post-init.el"
  (use-package howm
    :ensure t
    :defer t
    :bind (("C-c n ;" . howm-menu))
    :init
    (require 'howm-org)
    (setopt howm-directory "~/ndxrd-uxxs3/notes")
    (setopt howm-follow-theme t)
    (setopt howm-file-name-format "%Y%m%dT%H%M%S.org")
    (setopt howm-view-title-header "#+title:")

    :config
    ;; (add-hook 'howm-mode-hook #'tab-line-mode)
    ;; In case you don't always use Org-mode files, the following lines
    ;; ensure that Denote's title format for plain-text and Markdown files
    ;; will also be recognized.
    (setopt howm-view-title-regexp
            "^#?\\+?[tT][iI][tT][lL][eE]:\\( +\\(.*\\)\\|\\)$")
    (setopt howm-view-title-regexp-grep "^(#?\\+?[tT][iI][tT][lL][eE]:) +")

    ;; Advise `howm-view-item-basename' so that if its return value
    ;; includes "--", only the text before is returned.
    (defun my/howm-basename-chop (str)
      "Advice for `howm-view-item-basename'.
      Takes a file's basename, STR, and returns only the portion before
      \"--\"."
      (let ((dashes-pos (string-match "--" str)))
        (cond (dashes-pos (substring str 0 dashes-pos))
              (t str))))

    (advice-add 'howm-view-item-basename :filter-return
                'my/howm-basename-chop)

    ;; Advise `howm-view-item-summary' so that it removes the "#+title: "
    ;; portion of note titles.
    ;; (defvar howm-view-title-regexp)
    (defun my/howm-cut-title (str)
      "Remove `howm-view-title-header' plus whitespace from STR."
      (let ((begin (when (string-match howm-view-title-regexp str)
                     (match-beginning 2))))
        (if begin (substring str begin) str)))

    (advice-add 'howm-view-item-summary :filter-return 'my/howm-cut-title)
    )
#+end_src
*** Denote
#+name: denote_config
#+begin_src emacs-lisp
  (setq my-notes-dir           (expand-file-name     "~/ndxrd-uxxs3/notes/"))
  (setq my-journals-dir        (concat my-notes-dir  "journals"))
  (setq my-zettels-dir         (concat my-notes-dir  "main"))
  (setq my-templates-dir       (concat my-notes-dir  "templates"))
  (setq my-reference-notes-dir (concat my-notes-dir  "reference"))
  (setq my-inbox-notes-dir     (concat my-notes-dir  "inbox"))

  (use-package denote
    ;; :demand
    :custom
    (denote-directory my-notes-dir)
    (denote-known-keywords '("emacs" "programming" "architecture"))
    (denote-file-type 'org) ;; or 'markdown-yaml
    (denote-infer-keywords t)
    (denote-sort-keywords t)
    (denote-date-prompt-use-org-read-date t)
    (denote-backlinks-show-context t)
    (denote-rename-buffer-mode t)
    (denote-prompts '(title keywords))
    (denote-templates
     `((weekly-review . ,(f-read (expand-file-name
                                  "weekly-review.md"
                                  my-templates-dir)))
       (journal . "")))
    :config
    (defun my-weekly-review-journal ()
      "Create an entry tagged 'weeklyreview' with the year and week as
         its title using the 'weekly-review' template. If a note for
         the current week exists, visit it.  If multiple entries
         exist, prompt with completion for a choice between them.
         Else create a new file."
      (interactive)
      (let* ((denote-directory my-journals-dir)
             ;; Year corresponding to ISO week + ISO week
             (week (format-time-string "%G W%V"))
             (string (denote-sluggify 'title week))
             (files (denote-directory-files string))
             )
        (cond
         ((> (length files) 1)
          (find-file (completing-read "Select file: " files nil :require-match)))
         (files
          (find-file (car files)))
         (t
          (denote week '("weeklyreview") nil nil nil 'weekly-review)))))
    (defun my/denote-zettel ()
      "Create a permanent Zettelkasten note with Folgezettel ID."
      (interactive)
      (let ((denote-directory my-zettels-dir))
        (call-interactively #'denote-sequence)))
    (defun my/denote-inbox-note ()
      "Create a note in the inbox."
      (interactive)
      (let ((denote-directory my-inbox-notes-dir))
        (call-interactively #'denote)))
    (defun my/create-reference-note ()
      "Create a reference note in my zettelkasten reference folder"
      (interactive)
      (let ((denote-directory my-reference-notes-dir)
            (denote-known-keywords '("books" "music" "shows" "movies" "talks" "podcast")))
        (call-interactively #'denote)))
    :hook (dired-mode . denote-dired-mode)
    :bind
    ( :map global-map
      ("C-c n n" . my/denote-inbox-note)
      ("C-c n N" . my/denote-zettel)
      ("C-c n d" . (lambda () (interactive) (dired my-notes-dir)))
      ("C-c n D" . denote-sequence-dired)
      ("C-c n r" . my-weekly-review-journal)
      ("C-c n l" . my/create-reference-note)
      )
    ( :map text-mode-map
      ("C-c n i" . denote-link)
      ("C-c n R" . denote-rename-file-using-front-matter)
      )
    )
  (use-package denote-journal
    :after denote
    :hook (calendar-mode . denote-journal-calendar-mode)
    :custom
    (denote-journal-directory my-journals-dir)
    (denote-journal-title-format 'day-date-month-year)
    :config
    (require 'denote)
    :bind
    ("C-c n j" . denote-journal-new-or-existing-entry)
    )
  (use-package denote-menu
    :after denote)
  (use-package denote-sequence
    :after denote
    :config
    (require 'denote)
    :custom
    (denote-sequence-scheme 'alphanumeric))
  (use-package denote-org
    :after denote)
  (use-package consult-notes
    :after denote
    :init
    (require 'denote)
    :config
    (consult-notes-denote-mode 1)
    :bind
    ("C-c n f" . consult-notes)
    ("C-c n s" . consult-notes-search-in-all-notes)
    )
#+end_src
#+begin_src emacs-lisp :tangle "post-init.el" :noweb yes
  <<denote_config>>
#+end_src
#+begin_src emacs-lisp :tangle "~/ndxrd-uxxs3/notes/denote_config.el" :epilogue (format-time-string ";; Last generated on %c")
  ;;; post-init.el --- -*- no-byte-compile: t; lexical-binding: t; -*-
  ;; This file has been generated from my emacs's config.org file and is for
  ;; reference purposes only. DO NOT EDIT.
#+end_src
#+begin_src emacs-lisp :tangle "~/ndxrd-uxxs3/notes/denote_config.el" :noweb yes
  <<denote_config>>
#+end_src
*** Literature Notes from Koreader
#+name: koreader_config
#+begin_src emacs-lisp
  ;; KOReader configuration
  (require 'koreader-json-to-org)
  (setq my-koreader-export-dir  (expand-file-name "~/ndxrd-uxxs3/Documents/koreader/clipboard/"))
  (setq my-koreader-output-dir  (concat my-notes-dir "reference/"))
  (setq koreader-denote-tag "books:inbox")

  (defun my/koreader-import-all (&optional skip-sync)
    "Import all unprocessed KOReader JSON files from export directory.
  First syncs files from KOReader device via SCP, then processes JSON files
  from `my-koreader-export-dir' and creates org files in `my-koreader-output-dir'.
  Skips files that have already been processed based on their export timestamp.

  With prefix argument (C-u), skip the SCP sync step.

  Uses `koreader-use-denote' and other koreader-* customization variables
  to control output format and behavior."
    (interactive "P")
    (require 'koreader-json-to-org)

    ;; Sync files from KOReader device (unless skipped)
    (unless skip-sync
      (message "Syncing files from KOReader device...")
      (let* ((scp-command "scp -r -P 2222 root@192.168.4.30:/mnt/us/koreader/clipboard/ ~/ndxrd-uxxs3/Documents/koreader/")
             (exit-code (shell-command scp-command)))
        (unless (zerop exit-code)
          (user-error "Failed to sync files from KOReader device (exit code: %d)" exit-code))))

    (unless (file-directory-p my-koreader-export-dir)
      (user-error "KOReader export directory does not exist: %s" my-koreader-export-dir))
    (unless (file-directory-p my-koreader-output-dir)
      (make-directory my-koreader-output-dir t))
    (let ((results (koreader-process-json-directory
                    my-koreader-export-dir
                    my-koreader-output-dir)))
      (message "KOReader import complete: %d books processed, %d skipped, %d new highlights, %d existing"
               (plist-get results :files-processed)
               (plist-get results :files-skipped)
               (plist-get results :total-new)
               (plist-get results :total-skipped))))

#+end_src
#+begin_src emacs-lisp :tangle "post-init.el" :noweb yes
  <<koreader_config>>
#+end_src
#+begin_src emacs-lisp :tangle "~/ndxrd-uxxs3/notes/denote_config.el" :noweb yes
  <<koreader_config>>
#+end_src
** Ediff
#+begin_src emacs-lisp :tangle "post-init.el"
  (use-package ediff
    :ensure nil
    :config
    (setq ediff-split-window-function 'split-window-horizontally)
    (setq ediff-window-setup-function 'ediff-setup-windows-plain)
    (defun my/command-line-diff (switch)
      (setq initial-buffer-choice nil)
      (let ((file1 (pop command-line-args-left))
            (file2 (pop command-line-args-left)))
        (ediff file1 file2)))
    ;; show the ediff command buffer in the same frame
    (add-to-list 'command-switch-alist '("-diff" . my/command-line-diff)))
#+END_SRC
** File tree
#+begin_src emacs-lisp :tangle "post-init.el"
  (use-package speedbar
    :ensure nil
    :custom
    (speedbar-prefer-window t))
  (use-package treemacs
    :init
    (with-eval-after-load 'winum
      (define-key winum-keymap (kbd "M-0") #'treemacs-select-window))
    :config
    (defun my-treemacs-toggle ()
      "Initialize or toggle treemacs.
  Ensures that only the current project is present and all other projects have
  been removed.
  Use `treemacs' command for old functionality."
      (interactive)
      (pcase (treemacs-current-visibility)
        (`visible (delete-window (treemacs-get-local-window)))
        (_ (treemacs-add-and-display-current-project))))
    (treemacs-project-follow-mode 1)
    :custom
    (treemacs-follow-after-init t)
    (treemacs-is-never-other-window t)
    (treemacs-follow-mode -1)
    :bind
    (:map global-map
          ("M-0"       . treemacs-select-window)
          ("C-x M-0"   . my-treemacs-toggle))
    )
  (use-package treemacs-evil
    :disabled
    :after (treemacs evil)
    :ensure t)

  (use-package treemacs-icons-dired
    :hook (dired-mode . treemacs-icons-dired-enable-once)
    :ensure t)

  (use-package treemacs-magit
    :after (treemacs magit)
    :ensure t)
#+end_src
** Tramp
#+begin_src emacs-lisp :tangle "post-init.el"
  (setopt remote-file-name-inhibit-locks t
          tramp-use-scp-direct-remote-copying t
          remote-file-name-inhibit-auto-save-visited t)
  (setopt tramp-copy-size-limit (* 1024 1024) ;; 1MB
          tramp-verbose 2)
#+end_src

** COMMENT Workspaces - beframe
#+begin_src emacs-lisp :tangle "post-init.el"
  (use-package beframe
    :demand
    :custom
    (beframe-functions-in-frames '(project-prompt-project-dir))
    :config
    (beframe-mode 1)
    (defvar consult-buffer-sources)
    (declare-function consult--buffer-state "consult")

    (with-eval-after-load 'consult
      (defface beframe-buffer
        '((t :inherit font-lock-string-face))
        "Face for `consult' framed buffers.")

      (defun my-beframe-buffer-names-sorted (&optional frame)
        "Return the list of buffers from `beframe-buffer-names' sorted by visibility.
    With optional argument FRAME, return the list of buffers of FRAME."
        (beframe-buffer-names frame :sort #'beframe-buffer-sort-visibility))

      (defvar beframe-consult-source
        `( :name     "Frame-specific buffers (current frame)"
           :narrow   ?F
           :category buffer
           :face     beframe-buffer
           :history  beframe-history
           :items    ,#'my-beframe-buffer-names-sorted
           :action   ,#'switch-to-buffer
           :state    ,#'consult--buffer-state))

      (add-to-list 'consult-buffer-sources 'beframe-consult-source))

    (define-key global-map (kbd "C-c b") #'beframe-prefix-map)
    ;; (global-set-key (kbd "C-b") 'consult-buffer)
    ;; (define-key evil-normal-state-map (kbd "C-b") 'consult-buffer)
    ;; TODO: ↑ does not work in org agenda
    )

#+end_src
** Dictionary and spelling
#+begin_src emacs-lisp :tangle "post-init.el"
  (use-package jinx
    :hook (text-mode . jinx-mode)
    :bind ("M-$" . jinx-correct)
    )
#+END_SRC
** Presentations
#+begin_src emacs-lisp :tangle "post-init.el"
  (use-package org-present
    :demand t)
  (use-package visual-fill-column
    :demand t
    :config
    (setq visual-fill-column-width 30
          visual-fill-column-center-text t))

  (defun my/org-present-start ()
    (org-present-big)
    (org-display-inline-images)
    ;; (org-present-hide-cursor)
    ;; (org-present-read-only)
    (setq header-line-format " ")
    (mode-line-invisible-mode 1)
    (scroll-bar-mode -1)
    ;; Center the presentation and wrap lines
    (visual-fill-column-mode 1)
    (visual-line-mode 1))

  (defun my/org-present-end ()
    (org-present-small)
    (org-remove-inline-images)
    ;; (org-present-show-cursor)
    ;; (org-present-read-write)
    (setq header-line-format nil)
    (mode-line-invisible-mode -1)
    (scroll-bar-mode 1)
    ;; Stop centering the document
    (visual-fill-column-mode 0)
    (visual-line-mode 0))

  ;; Register hooks with org-present
  (add-hook 'org-present-mode-hook 'my/org-present-start)
  (add-hook 'org-present-mode-quit-hook 'my/org-present-end)

  (defun my/org-present-prepare-slide (buffer-name heading)
    ;; Show only top-level headlines
    (org-overview)
    ;; Unfold the current entry
    (org-show-entry)
    ;; Show only direct subheadings of the slide but don't expand them
    (org-show-children))
  ;; (add-hook 'org-present-after-navigate-functions 'my/org-present-prepare-slide)
#+end_src

** Eglot
#+begin_src emacs-lisp :tangle "post-init.el"
  (use-package eglot
    :ensure nil
    :defer t
    :commands (eglot
               eglot-ensure
               eglot-rename
               eglot-format-buffer))

  (use-package eldoc
    :ensure nil
    :diminish eldoc-mode)
#+end_src
** AI Assistants
#+begin_src emacs-lisp :tangle "post-init.el"

  (use-package aidermacs
    :bind (("C-c M-a" . aidermacs-transient-menu))
    :custom
    (aidermacs-default-chat-mode 'architect)
    (aidermacs-default-model "sonnet")
    (aidermacs-auto-commits nil)
    (aidermacs-backend 'vterm)
    (aidermacs-watch-files t)
    )

  (use-package claudemacs
    :ensure (:host github :repo "cpoile/claudemacs")
    :bind (
           :map prog-mode-map
           ("C-c C-e" . claudemacs-transient-menu)
           :map text-mode-map
           ("C-c C-e" . claudemacs-transient-menu)
           )
    :init
    (add-to-list 'display-buffer-alist
                 '("^\\*claudemacs"
                   (display-buffer-in-side-window)
                   (mode-line-invisible-mode 1)
                   (side . right)
                   (window-width . 0.33)))
    :config
    (with-eval-after-load 'eat
      (setq eat-term-scrollback-size 400000))
    )

  (use-package claude-code-ide
    :ensure (:host github :repo "manzaltu/claude-code-ide.el")
    :bind ("C-c C-'" . claude-code-ide-menu) ; Set your favorite keybinding
    :custom
    (claude-code-ide-terminal-backend 'vterm)
    (claude-code-ide-use-ide-diff nil)
    :config
    (claude-code-ide-emacs-tools-setup))

  (use-package gptel
    :if (not my-phone-p)
    :bind
    ("C-c g g" . (lambda () (interactive) 
                   (switch-to-buffer (gptel "*Claude*"))))
    ("C-c g s" . gptel-send)
    ("C-c g m" . gptel-menu)
    ("C-c g r" . gptel-rewrite)
    ("C-c g t" . gptel-tools)
    :config
    (setq
     gptel-track-media t
     gptel-default-mode #'org-mode
     gptel-model 'claude-sonnet-4-20250514
     gptel-backend (gptel-make-anthropic "Claude"
                     :stream t
                     :key (lambda ()
                            (auth-source-pick-first-password :host "api.anthropic.com" :user "credential"))
                     ))
    (setf (alist-get 'org-mode gptel-prompt-prefix-alist) "@srijan\n")
    (setf (alist-get 'org-mode gptel-response-prefix-alist) "@claude\n")
    (require 'gptel-plus)
    )
  (use-package acp
    :ensure (:host github :repo "xenodium/acp.el")
    :demand t
    )
  (use-package shell-maker
    :demand t)
  (use-package agent-shell
    :ensure (:host github :repo "xenodium/agent-shell")
    :demand t
    :config
    (setq agent-shell-anthropic-authentication
          (agent-shell-anthropic-make-authentication :login t))
    )
  (use-package gptel-plus
    :ensure (:host github :repo "benthamite/gptel-plus"))
  (use-package gptel-tool-library
    :if (not my-phone-p)
    :ensure (:host github :repo "aard-fi/gptel-tool-library")
    :after gptel
    :init
    (require 'gptel-tool-library)
    :config
    ;; set this if you want to use maybe safe functions (recommended)
    ;;(setq gptel-tool-library-use-maybe-safe t)
    ;; set this if you also want to use unsafe functions
    ;;(setq gptel-tool-library-use-unsafe t)
    (dolist (module '("buffer" "elisp" "emacs" "os"))
      (gptel-tool-library-load-module module))
    )


  (use-package copilot
    :disabled
    :if (not my-phone-p)
    :diminish
    ;; :straight (:host github :repo "zerolfx/copilot.el" :files ("dist" "*.el"))
    :ensure t
    :hook (prog-mode . (lambda ()
                         (interactive)
                         (unless (file-remote-p default-directory)
              		     (copilot-mode))))
    :custom
    (copilot-max-char 1000000)
    :bind (
           ;; ("C-TAB" . 'copilot-accept-completion-by-word)
           ;; ("C-<tab>" . 'copilot-accept-completion-by-word)
           :map copilot-completion-map
           ("<tab>" . 'copilot-accept-completion)
           ("TAB" . 'copilot-accept-completion))
    :config
    (add-to-list 'copilot-indentation-alist '(prog-mode 2))
    (add-to-list 'copilot-indentation-alist '(org-mode 2))
    (add-to-list 'copilot-indentation-alist '(text-mode 2))
    (add-to-list 'copilot-indentation-alist '(closure-mode 2))
    (add-to-list 'copilot-indentation-alist '(emacs-lisp-mode 2))
    (add-to-list 'copilot-indentation-alist '(markdown-mode 2))
    )

  (use-package chatgpt-shell
    :if (not my-phone-p)
    :ensure t
    :custom
    ((chatgpt-shell-openai-key
      (lambda ()
        (auth-source-pick-first-password :host "openai-key" :user "credential")))))

#+end_src
** Misc for software dev
#+begin_src emacs-lisp :tangle "post-init.el"
  (when (not my-phone-p)
    (use-package mermaid-mode)
    (use-package sql-indent)
    (use-package xmind-org))
#+END_SRC
** Git
#+begin_src emacs-lisp :tangle "post-init.el"
  (use-package project
    :ensure nil
    :config
    (setopt project-vc-extra-root-markers '(".project")))
  (use-package transient)
  (use-package magit
    :bind ("C-x g" . magit-status)
    :custom
    (magit-git-executable (cond
                           (my-linux-p "/usr/bin/git")
                           (my-mac-p "/opt/homebrew/bin/git")
                           (t "git"))))
#+end_src
** Language Modes
#+begin_src emacs-lisp :tangle "post-init.el"
  (editorconfig-mode 1)
  (use-package markdown-mode
    :mode ("README\\.md\\'" . gfm-mode)
    :init (setq markdown-command '("pandoc" "--from=markdown" "--to=html5"))
    :bind (:map markdown-mode-map
                ("M-n" . nil)))
  (use-package edit-indirect)
  (use-package json-mode)
  (use-package js
    :ensure nil
    :custom
    (js-indent-level 2))
  (when my-windows-p
    (use-package ahk-mode))
  (use-package php-mode)
  ;; (use-package jsonnet-mode)
  ;; (use-package hierarchy)
  (use-package tree-mode)
  (use-package json-navigator)
  (use-package pet
    :config
    (add-hook 'python-base-mode-hook 'pet-mode -10))
  (use-package fish-mode)
  (use-package jupyter :disabled)
  (use-package edraw-org
    :ensure (:host github :repo "misohena/el-easydraw")
    :after org
    :config
    (edraw-org-setup-default))

#+END_SRC
** Erlang & LSP
#+begin_src emacs-lisp :tangle "post-init.el"
  (use-package yasnippet
    :diminish (yas-minor-mode)
    :demand t
    :custom
    (yas-snippet-dirs (list (expand-file-name "snippets" minimal-emacs-user-directory)))
    :config
    (yas-global-mode t)
    )

  ;; Install the official Erlang mode
  (when my-linux-p
    (add-to-list
     'load-path (car (file-expand-wildcards
                      "/usr/lib/erlang/lib/tools-*/emacs"))))
  (when my-windows-p
    (add-to-list
     'load-path (car (file-expand-wildcards
                      "/Program Files/Erlang OTP/lib/tools-*/emacs"))))
  (when my-mac-p
    (add-to-list
     'load-path (car (file-expand-wildcards
                      "/opt/homebrew/opt/erlang/lib/erlang/lib/tools-*/emacs"))))
  (when (not my-phone-p)
    (use-package erlang
      :ensure nil
      ;; :demand t
      :hook ((erlang-mode . display-line-numbers-mode)
             (erlang-mode . column-number-mode))
      :custom
      (erlang-electric-commands '(erlang-electric-comma
                                  erlang-electric-semicolon
                                  erlang-electric-gt
                                  erlang-electric-newline))
      :init
      (require 'erlang-start)
      )
    (use-package indy
      :disabled
      :custom
      (setq indy-rules
            '((erlang-mode . (
                              ;; ((indy--current 'indy--starts-with "]") (indy--prev-tab -1))
                              ;; ((indy--prev    'indy--ends-on "[")     (indy--prev-tab 1))
                              ;; ((indy--prev    'indy--ends-on ",")     (indy--prev-tab))

  			                ((and (indy--current 'indy--starts-with "end")
  				                  (indy--prev 'indy--ends-on ") ->"))      (indy--prev-tab))
  			                ((indy--current 'indy--starts-with "end") (indy--prev-tab -1))
  			                ((indy--prev 'indy--ends-on ") ->")       (indy--prev-tab 1))
  			                ((indy--current 'indy--starts-with "]")   (indy--prev-tab -1))
  			                ((indy--prev 'indy--ends-on "[")          (indy--prev-tab 1))
  			                ((indy--prev 'indy--ends-on ",")          (indy--prev-tab))
  			                ))
  	        )
            ))
    (use-package elixir-mode)

    (use-package eglot
      :ensure nil
      :hook (erlang-mode . eglot-ensure)
      :config
      (add-to-list 'eglot-server-programs
                   `(erlang-mode . ,(eglot-alternatives
                                     '(("erlang_ls" "--transport" "stdio")
                                       ("elp" "--log-file" "elp.log" "server")))))

      (add-hook 'eglot-managed-mode-hook
                (lambda ()
                  ;; Show flymake diagnostics first.
                  (setq eldoc-documentation-functions
                        (cons #'flymake-eldoc-function
                              (remove #'flymake-eldoc-function eldoc-documentation-functions)))
                  ;; Show all eldoc feedback.
                  (setq eldoc-documentation-strategy #'eldoc-documentation-compose)))
      )
    )
#+END_SRC
** Docker and Kubernetes
#+begin_src emacs-lisp :tangle "post-init.el"
  (use-package dockerfile-mode)
  (use-package yaml-mode)
  (use-package kubernetes
    :ensure t
    :commands (kubernetes-overview kubernetes-events)
    :config
    (setq kubernetes-poll-frequency 3600
          kubernetes-redraw-frequency 3600))
  (use-package kubernetes-evil
    :disabled
    :ensure t
    :after kubernetes)
#+end_src
** mu4e
#+begin_src emacs-lisp :tangle "post-init.el"
  (use-package gnus
    :ensure nil
    :custom
    (gnus-inhibit-mime-unbuttonizing t)
    (mm-discouraged-alternatives '("text/html" "text/richtext")))

  (when my-mac-p
    (add-to-list
     'load-path (car (file-expand-wildcards
                      "/opt/homebrew/share/emacs/site-lisp/mu/mu4e"))))
  (use-package mu4e
    :if (not my-phone-p)
    :ensure nil
    ;; :if my-linux-p
    ;; :hook (evil-collection-setup . (lambda (&rest a)
    ;;                                  (evil-define-key 'normal mu4e-headers-mode-map "z%" 'mu4e-headers-mark-thread)
    ;;                                  ))
    ;; :bind (:map mu4e-view-mode-map
    ;;             ("K" .
    ;;              (lambda ()
    ;;              (interactive)
    ;;              (gnus-article-jump-to-part 1)
    ;;              (gnus-article-press-button)
    ;;           (gnus-article-press-button))))
    :bind (("C-c m" . mu4e))
    :autoload mu4e-update-index
    :config
    (setq
     ;; mu4e-use-maildirs-extension nil
     mu4e-view-prefer-html nil
     ;; mu4e-get-mail-command "~/.local/bin/mailsync.sh" ;; "mbsync fastmail-all"
     mu4e-get-mail-command "mbsync fastmail-all" ;; "mbsync fastmail-all"
     ;; mu4e-update-interval 180
     mu4e-headers-auto-update t
     mu4e-search-include-related nil
     mu4e-compose-signature-auto-include nil
     mu4e-compose-format-flowed t
     mu4e-use-fancy-chars t
     mu4e-headers-visible-flags '(draft flagged new passed replied trashed attach encrypted signed)
     mu4e-headers-fields '((:human-date . 12)
                           (:flags . 6)
                           (:from-or-to . 32)
                           (:subject))
     mu4e-headers-date-format "%Y-%m-%d"
     mu4e-headers-from-or-to-prefix '("" . "To: ")
     mu4e-headers-leave-behavior 'apply
     mu4e-hide-index-messages t
     message-kill-buffer-on-exit t
     shr-color-visible-luminance-min 80
     mu4e-index-cleanup nil ;; set to nil if indexing is slow
     mu4e-index-lazy-check t
     )


    (defun my-mu4e-refile-folder-fun (msg)
      "Set the refile folder for MSG."
      (let ((date (mu4e-message-field msg :date)))
        (cond
         (date
          (format "/fastmail/Archive/%s" (format-time-string "%Y" date)))
         (t
          "/fastmail/Archive"))))

    (setq user-full-name "Srijan Choudhary"
          mu4e-sent-folder "/fastmail/Sent Items"
          mu4e-drafts-folder "/fastmail/Drafts"
          mu4e-trash-folder "/fastmail/Trash"
          ;; mu4e-refile-folder "/fastmail/Archive"
          mu4e-refile-folder 'my-mu4e-refile-folder-fun
          mu4e-attachment-dir  "~/Downloads"
          )

    ;; enable inline images
    (setq mu4e-view-show-images t)

    ;; use imagemagick, if available
    (when (fboundp 'imagemagick-register-types)
      (imagemagick-register-types))

    ;; every new email composition gets its own frame!
    ;; (setq mu4e-compose-in-new-frame t)

    ;; don't save message to Sent Messages, IMAP takes care of this
    (setq mu4e-sent-messages-behavior 'sent)

    (add-hook 'mu4e-view-mode-hook #'visual-line-mode)

    ;; <tab> to navigate to links, <RET> to open them in browser
    (add-hook 'mu4e-view-mode-hook
              (lambda()
                ;; try to emulate some of the eww key-bindings
                (local-set-key (kbd "<RET>") 'mu4e~view-browse-url-from-binding)
                (local-set-key (kbd "<tab>") 'shr-next-link)
                (local-set-key (kbd "<backtab>") 'shr-previous-link)))

    ;; spell check
    (add-hook 'mu4e-compose-mode-hook
              (defun my-do-compose-stuff ()
                "My settings for message composition."
                (visual-line-mode)
                ;; (org-mu4e-compose-org-mode)
                (use-hard-newlines -1)
                ;; (flyspell-mode)
                ))

    ;;rename files when moving
    ;;NEEDED FOR MBSYNC
    (setq mu4e-change-filenames-when-moving t)

    ;; bookmarks
    (add-to-list 'mu4e-bookmarks
                 '( :name  "Inbox GO"
                    :query "maildir:\"/fastmail/Inbox GO\""
                    :key   ?g))
    (add-to-list 'mu4e-bookmarks
                 '( :name  "Inbox Personal"
                    :query "maildir:\"/fastmail/Inbox\""
                    :key   ?p))
    (add-to-list 'mu4e-bookmarks
                 '( :name  "Sent Items"
                    :query "maildir:\"/fastmail/Sent Items\""
                    :key   ?s))
    (add-to-list 'mu4e-bookmarks
                 '( :name  "Memos"
                    :query "\"maildir:/fastmail/Memos\""
                    :key   ?m))
    (add-to-list 'mu4e-bookmarks
                 '( :name  "Waiting For Support"
                    :query "\"maildir:/fastmail/@Waiting For Support\""
                    :key   ?f))
    (add-to-list 'mu4e-bookmarks
                 '( :name  "Action Support"
                    :query "\"maildir:/fastmail/@Action Support\""
                    :key   ?a))
    (add-to-list 'mu4e-bookmarks
                 '( :name  "Inbox"
                    :query "\"maildir:/fastmail/Inbox\" or \"maildir:/fastmail/Inbox GO\""
                    :key   ?i))

    ;; set mail user agent
    (setq mail-user-agent 'mu4e-user-agent
          message-mail-user-agent 'mu4e-user-agent)

    ;; Setup mu4e contexts. This is to enable adding multiple email contexts if needed in the future.
    ;; I will initially only enable my fastmail context but adding a new one shouldn't be harder than copying
    ;; the existing context and modifying the settings.
    (setq mu4e-context-policy 'pick-first)
    (setq mu4e-compose-context-policy 'ask)
    (setq mu4e-contexts
          (list
           (make-mu4e-context
            :name "fastmail"
            :enter-func (lambda () (mu4e-message "Entering context fastmail"))
            :leave-func (lambda () (mu4e-message "Leaving context fastmail"))
            :match-func (lambda (msg)
                          (when msg
                            (mu4e-message-contact-field-matches
                             msg '(:from :to :cc :bcc) "srijan@fastmail.com")))
            :vars '((user-mail-address . "srijan@fastmail.com")
                    (mu4e-compose-signature . (concat "Srijan Choudhary\n" "https://srijan.ch\n"))
                    (mu4e-compose-format-flowed . t)
                    ))
           (make-mu4e-context
            :name "personal"
            :enter-func (lambda () (mu4e-message "Entering context personal"))
            :leave-func (lambda () (mu4e-message "Leaving context personal"))
            :match-func (lambda (msg)
                          (when msg
                            (mu4e-message-contact-field-matches
                             msg '(:from :to :cc :bcc) "srijan4@gmail.com")))
            :vars '((user-mail-address . "srijan4@gmail.com")
                    (mu4e-compose-signature . (concat "Srijan Choudhary\n" "https://srijan.ch\n"))
                    (mu4e-compose-format-flowed . t)
                    ))
           (make-mu4e-context
            :name "greyorange"
            :enter-func (lambda () (mu4e-message "Entering context greyorange"))
            :leave-func (lambda () (mu4e-message "Leaving context greyorange"))
            :match-func (lambda (msg)
                          (when msg
                            (mu4e-message-contact-field-matches
                             msg '(:from :to :cc :bcc) "srijan.c@greyorange.com")))
            :vars '((user-mail-address . "srijan.c@greyorange.com")
                    (mu4e-compose-signature . "Srijan Choudhary\n")
                    (mu4e-compose-format-flowed . t)
                    ))
           ))

    ;; Allow replying to calendar events
    ;; https://www.djcbsoftware.nl/code/mu/mu4e/iCalendar.html
    (require 'mu4e-icalendar)
    (mu4e-icalendar-setup)
    (setq mu4e-icalendar-trash-after-reply t)
    ;; (mu4e t) ;; Start mu4e in the background
    )
  (use-package mu4e-views
    :disabled
    )
  (use-package org
    :ensure nil
    :after mu4e
    :bind (
           :map mu4e-headers-mode-map
           ("C-c i" . org-capture-mail)
           ;; ("z m" . mu4e-view-mark-thread)
           :map mu4e-view-mode-map
           ("C-c i" . org-capture-mail))
    )

  (use-package org-msg
    ;; Issues with mu 1.12 right now
    :disabled
    ;; :if my-linux-p
    :config
    (setq org-msg-options "html-postamble:nil H:5 num:nil ^:{} toc:nil author:nil email:nil \\n:t"
          org-msg-startup "hidestars indent inlineimages"
          org-msg-default-alternatives '((new             . (text html))
                                         (reply-to-html   . (text html))
                                         (reply-to-text   . (text)))
          org-msg-convert-citation t
          org-msg-signature "

     ,#+begin_signature
     --
     ,*Srijan Choudhary*
     ,#+end_signature")
    (org-msg-mode)
    )

  (use-package smtpmail
    :if (not my-phone-p)
    ;; :if my-linux-p
    :ensure nil
    :config

    (setq sendmail-program "/usr/bin/msmtp"
          send-mail-function 'smtpmail-send-it
          message-sendmail-f-is-evil t
          ;; This allows msmtp to automatically choose the correct account
          ;; based on from header.
          message-sendmail-extra-arguments '("--read-envelope-from")
          message-send-mail-function 'message-send-mail-with-sendmail
          smtpmail-debug-info t
          smtpmail-debug-verbose t
          )
    (when (eq system-type 'darwin)
      (setq sendmail-program "/opt/homebrew/bin/msmtp"))

    (setq smtpmail-queue-mail nil)
    (setq smtpmail-queue-dir "~/Maildir/queue/cur")
    )
#+end_src
** notmuch
#+begin_src emacs-lisp :tangle "post-init.el"
  (use-package notmuch
    :disabled
    :config
    (setopt notmuch-search-oldest-first nil)
    (setopt notmuch-saved-searches
            '((:name "Inbox" :query "tag:inbox" :key "i")
              (:name "Unread" :query "tag:unread" :key "u")
              (:name "Sent" :query "tag:sent" :key "s")
              (:name "Archive" :query "not tag:inbox" :key "a")
              ;; Add saved searches for your other "folders"
              (:name "Inbox GO" :query "tag:inbox AND tag:work" :key "w")
              (:name "Inbox Personal" :query "tag:inbox AND -tag:work" :key "p")))
    )
#+end_src

** JIRA
#+begin_src emacs-lisp :tangle "post-init.el"
  (use-package jira
    :if (not my-phone-p)
    :ensure (:host github :repo "unmonoqueteclea/jira.el")
    :demand t
    :config
    (setq jira-base-url "https://work.greyorange.com/jira")
    (setq jira-username "srijan.c@greyorange.com")
    (setq jira-token-is-personal-access-token t)
    (setq jira-api-version 2)
    (setq jira-issues-table-fields
          '(:key :issue-type-name :status-name :reporter-name :assignee-name :components :labels :summary))
    (setq jira-debug nil)
    (setq jira-detail-show-announcements nil)

    (defun jira-api--token ()
      (auth-source-pick-first-password
       :host "work.greyorange.com-jira" :user "credential"))

    ;; Issue fields customizations
    (add-to-list 'jira-issues-fields
                 '(:epic-link . ((:path . (fields customfield_10002))
                                 (:columns . 5)
                                 (:name . "Epic Link"))))

    (defun sj/jira-visit-issue-at-point ()
      "Visit the jira issue detail page for the jira key under point."
      (interactive)
      (require 'jira-complete)
      (require 'jira-detail)
      (let ((key (jira-complete--find-key-at-point)))
        (if key
            (jira-detail-show-issue key)
          (message "No Jira issue key found at point"))))

    ;; Embark integration for Jira issue keys
    (with-eval-after-load 'embark
      (defun sj/embark-target-jira-key ()
        "Target a Jira issue key at point for embark actions."
        (require 'jira-complete)
        (when-let ((key (jira-complete--find-key-at-point)))
          (when (jira-complete--validate-key key)
            (let ((bounds (bounds-of-thing-at-point 'symbol)))
              `(jira-key ,key . ,bounds)))))

      (add-to-list 'embark-target-finders 'sj/embark-target-jira-key)

      (defvar-keymap embark-jira-key-map
        :doc "Keymap for Jira issue key actions."
        :parent embark-general-map
        "v" (cons "Visit issue detail page in Emacs"
                  (lambda (key)
                    (interactive "s")
                    (require 'jira-detail)
                    (jira-detail-show-issue key)))
        "o" (cons "Open Jira issue in browser"
                  (lambda (key)
                    (interactive "s")
                    (require 'jira-actions)
                    (jira-actions-open-issue key)))
        "c" (cons "Copy issue key to clipboard"
                  (lambda (key)
                    (interactive "s")
                    (require 'jira-actions)
                    (jira-actions-copy-issues-id-to-clipboard key))))

      (add-to-list 'embark-keymap-alist '(jira-key . embark-jira-key-map)))
    )

#+end_src
** Document Reader
#+begin_src emacs-lisp :tangle "post-init.el"
  (when my-linux-p
    (use-package reader
      :ensure (:host codeberg :repo "divyaranjan/emacs-reader"
    	               :files ("*.el" "render-core.so")
    	               :pre-build ("make" "all"))))
  (when my-mac-p
    (use-package reader
      :ensure (:host codeberg :repo "divyaranjan/emacs-reader"
    	               :files ("*.el" "render-core.dylib")
    	               :pre-build ("make" "all"))))
#+end_src
** Social and Browser
*** EWW Browser
#+begin_src emacs-lisp :tangle "post-init.el"
  (use-package eww
    :ensure nil
    :demand t)
  (defcustom sj-browse-url-handlers `()
    "Alist of (KEY REGEX-LIST . FUNCTION) pairs for URL handling.
    KEY is a symbol identifying the handler.
    REGEX-LIST is a list of regex patterns (strings) to match against URLs.
    FUNCTION is called with the URL when any regex matches."
    :type '(alist :key-type symbol
                  :value-type (cons (repeat string) function))
    :group 'sj-browse)

  (defcustom sj-browse-url-default-handler 'eww-browse-url
    "Default function to handle URLs when no regex matches."
    :type 'function
    :group 'sj-browse)

  (defun sj-browse-url-set-handler (key regex-list handler)
    "Set or update handler for KEY with REGEX-LIST and HANDLER function."
    (setq sj-browse-url-handlers
          (cons (cons key (cons regex-list handler))
                (assq-delete-all key sj-browse-url-handlers))))

  ;; Helper function to make rx usage cleaner
  (defun sj-browse-url-set-handler-rx (key rx-patterns handler)
    "Set handler for KEY with RX-PATTERNS (list of rx forms) and HANDLER function."
    (sj-browse-url-set-handler key
                               (mapcar (lambda (rx-form) (rx-to-string rx-form))
                                       rx-patterns)
                               handler))

  (defun sj-browse-url (url &optional new-window)
    "Browse URL using configured handlers or default handler."
    (interactive (browse-url-interactive-arg "URL: "))
    (let ((handler (or (cl-loop for (regex . func) in sj-browse-url-handlers
                                when (string-match-p regex url)
                                return func)
                       sj-browse-url-default-handler)))
      (funcall handler url new-window)))

  (defun sj-browse-url (url &optional new-window)
    "Browse URL using configured handlers or default handler."
    (interactive (browse-url-interactive-arg "URL: "))
    (let ((handler (or (cl-loop for (key regex-list . func) in sj-browse-url-handlers
                                when (cl-some (lambda (regex)
                                                (string-match-p regex url))
                                              regex-list)
                                return func)
                       sj-browse-url-default-handler)))
      (funcall handler url new-window)))


  (setopt browse-url-browser-function 'sj-browse-url)
#+end_src
*** Feeds
#+begin_src emacs-lisp :tangle "post-init.el"
  (use-package elfeed
    :custom
    (elfeed-use-curl t)
    (elfeed-log-level 'debug)
    (elfeed-search-title-max-width 120)
    :config
    (elfeed-set-timeout 36000)

    (defun elfeed-protocol-fever-sync-unread-stat (host-url)
      "Set all entries in search view to read and fetch latest unread entries.
  HOST-URL is the host name of Fever server with user field authentication info,
  for example \"https://user@myhost.com\"."
      (interactive
       (list (completing-read
              "feed: "
              (mapcar (lambda (fd)
                        (string-trim-left (car fd) "[^+]*\\+"))
                      elfeed-protocol-feeds))))
      (save-mark-and-excursion
        (mark-whole-buffer)
        (cl-loop for entry in (elfeed-search-selected)
                 do (elfeed-untag-1 entry 'unread))
        (elfeed-protocol-fever--do-update host-url 'update-unread)))

    (defun sj-elfeed-hard-refresh()
      "Performs a hard-refresh of the elfeed database and fetching everything from scratch"
      "Unload elfeed db, delete the directory, fever-reinit, and then open elfeed again
       Ask yes or no"
      (interactive)
      (when (yes-or-no-p "This will delete your elfeed database and re-fetch everything. Are you sure? ")
        (message "Deleting elfeed database...")
        (elfeed-db-unload)
        (delete-directory (expand-file-name elfeed-db-directory) t)
        (dolist (feed (elfeed-protocol-feed-list))
          (elfeed-protocol-fever-reinit (elfeed-protocol-url feed)))
        (elfeed)
        ))

    (defun sj-elfeed-search-toolbar ()
      (setq-local tool-bar-map (make-sparse-keymap))
      (tool-bar-local-item "open" 'elfeed-search-show-entry 'elfeed-open-button tool-bar-map
                           :help "Show Entry"
                           :vert-only t)
      (tool-bar-local-item "refresh" 'elfeed-search-update--force 'elfeed-view-refresh-button tool-bar-map
                           :help "Refresh the view"
                           :vert-only t)
      (tool-bar-local-item "newsticker/get-all" 'elfeed-search-fetch 'elfeed-update-button tool-bar-map
                           :help "Update elfeed sources"
                           :vert-only t)
      (tool-bar-local-item "search" 'elfeed-search-live-filter 'elfeed-search-button tool-bar-map
                           :help "Change elfeed display filter"
                           :vert-only t)
      (define-key-after tool-bar-map [separator-1] menu-bar-separator)
      (tool-bar-local-item "close" 'elfeed-search-quit-window 'elfeed-close-button tool-bar-map
                           :help "Close elfeed"
                           :vert-only t)
      (tool-bar-local-item "exit" 'kill-current-buffer 'elfeed-quit-button tool-bar-map
                           :help "Completely quit elfeed"
                           :vert-only t)
      (define-key-after tool-bar-map [separator-2] menu-bar-separator)
      (tool-bar-local-item "connect" 'sj-elfeed-hard-refresh 'elfeed-hard-refresh-button tool-bar-map
                           :help "Hard refresh elfeed"
                           :vert-only t)
      )
    (add-hook 'elfeed-search-mode-hook #'sj-elfeed-search-toolbar)

    (defun sj-elfeed-show-toolbar ()
      (setq-local tool-bar-map (make-sparse-keymap))
      (tool-bar-local-item "prev-node" 'elfeed-show-prev 'elfeed-show-prev-button tool-bar-map
                           :help "Previous Page"
                           :vert-only t)
      (tool-bar-local-item "next-node" 'elfeed-show-next 'elfeed-show-next-button tool-bar-map
                           :help "Next Page"
                           :vert-only t)
      (tool-bar-local-item "newsticker/browse-url" 'elfeed-show-visit 'elfeed-browse-button tool-bar-map
                           :help "Browse URL"
                           :vert-only t)
      (tool-bar-local-item "close" 'elfeed-kill-buffer 'elfeed-kill-buffer-button tool-bar-map
                           :help "Kill buffer"
                           :vert-only t)
      )
    (add-hook 'elfeed-show-mode-hook #'sj-elfeed-show-toolbar)

    (defun sj-elfeed-search-setup-toolbar ()
      "When elfeed-search-mode starts, enable tool-bar-here-mode, and setup a
       hook so that tool-bar-mode is disabled when the buffer is killed."
      (tool-bar-here-mode 1)
      (if (= 1 (length (default-value 'tool-bar-map))) (tool-bar-setup)) ;; had to add this for non-empty default toolbars
      (add-hook 'kill-buffer-hook #'(lambda() (tool-bar-here-mode -1)) -10 t))
    (add-hook 'elfeed-search-mode-hook #'sj-elfeed-search-setup-toolbar)

    )
  (use-package elfeed-protocol
    :custom
    (elfeed-protocol-feeds '(("fever+https://srijan@miniflux.nwdr.io"
                              :api-url "https://miniflux.nwdr.io/fever/"
                              :password (lambda ()
                                          (auth-source-pick-first-password :host "miniflux.nwdr.io" :user "fever")))))
    (elfeed-protocol-enabled-protocols '(fever))
    :hook (elfeed-search-mode . elfeed-protocol-enable)
    )
  (use-package elfeed-webkit :disabled)

#+END_SRC
*** Slack
#+begin_src emacs-lisp :tangle "post-init.el"
  (use-package slack
    :if (not my-phone-p)
    :ensure (:host github :repo "emacs-slack/emacs-slack")
    :bind (("C-c s K" . slack-stop)
           ("C-c s c" . slack-select-rooms)
           ("C-c s u" . slack-select-unread-rooms)
           ("C-c s U" . slack-user-select)
           ("C-c s s" . slack-search-from-messages)
           ("C-c s J" . slack-jump-to-browser)
           ("C-c s j" . slack-jump-to-app)
           ("C-c s e" . slack-insert-emoji)
           ("C-c s E" . slack-message-edit)
           ("C-c s r" . slack-message-add-reaction)
           ("C-c s t" . slack-all-threads)
           ("C-c s g" . slack-message-redisplay)
           ("C-c s G" . slack-conversations-list-update-quick)
           ("C-c s q" . slack-quote-and-reply)
           ("C-c s Q" . slack-quote-and-reply-with-link)
           (:map slack-mode-map
                 (("@" . slack-message-embed-mention)
                  ("#" . slack-message-embed-channel)))
           (:map slack-thread-message-buffer-mode-map
                 (("C-c '" . slack-message-write-another-buffer)
                  ("@" . slack-message-embed-mention)
                  ("#" . slack-message-embed-channel)))
           (:map slack-message-buffer-mode-map
                 (("C-c '" . slack-message-write-another-buffer)))
           (:map slack-message-compose-buffer-mode-map
                 (("C-c '" . slack-message-send-from-buffer)))
           )
    :config
    (setq slack-prefer-current-team t)
    (setq slack-enable-global-mode-string t)
    (setq slack-buffer-function 'switch-to-buffer)
    (setq slack-thread-also-send-to-room nil)
    (slack-register-team
     :name "greyorange"
     :default t
     :modeline-enabled t
     :token (auth-source-pick-first-password
             :host "work-slack-tokens"
             :user "token")
     :cookie (auth-source-pick-first-password
              :host "work-slack-tokens"
              :user "cookie"))
    )
  ;; (elpaca--configure-remotes (elpaca-get 'slack))
  (use-package alert
    :commands (alert)
    :init
    (require 'notifications)
    (setq alert-default-style 'notifications))

#+end_src
*** HackerNews
#+begin_src emacs-lisp :tangle "post-init.el"
  (use-package hnreader
    :demand t
    :config
    (defun my-hnreader-comments-readonly (dom url)
      (view-mode 1)
      (org-fold-show-all)
      )
    (advice-add
     'hnreader--print-comments
     :after
     'my-hnreader-comments-readonly
     )
    (sj-browse-url-set-handler-rx
     'hn
     '((seq line-start "https://" (or "news.ycombinator.com" "hnreader.com") "/item?id=" (one-or-more digit)))
     (lambda (url &rest _) (hnreader-comment url)))
    )
#+end_src
*** Mastodon
#+begin_src emacs-lisp :tangle "post-init.el"
  (use-package emojify
    :hook (after-init . global-emojify-mode))
  (use-package mastodon
    :if (not my-phone-p)
    ;; :straight (:package mastodon :host nil :type git :repo "https://codeberg.org/martianh/mastodon.el.git" :branch "develop")
    :ensure t
    :config
    (setq mastodon-instance-url "https://indieweb.social"
          mastodon-active-user "srijan")
    )
#+end_src
*** Reddit
#+begin_src emacs-lisp :tangle "post-init.el"
  (use-package reddigg
    :demand t
    :config
    (sj-browse-url-set-handler-rx
     'reddit
     '((seq line-start "http" (zero-or-one "s") "://www.reddit.com/" (one-or-more anychar)))
     (lambda (url &rest _) (reddigg-view-comments url)))
    ) 
#+end_src
*** GitHub
#+begin_src emacs-lisp :tangle "post-init.el"
  (use-package github-explorer
    :commands (github-explorer-repo-from-url)
    :init
    ;; (github-explorer (github-explorer-repo-from-url "https://github.com/srijan/emacs-v4"))
    (sj-browse-url-set-handler-rx
     'github
     '((seq line-start "http" (zero-or-one "s") "://github.com/" (one-or-more anychar)))
     (lambda (url &optional _new-window)
       (github-explorer (github-explorer-repo-from-url url))))
    )
    
#+end_src
** Desktop Utilities
- A script to set the default browser on Linux:
#+begin_src emacs-lisp :tangle "post-init.el"
  (use-package ready-player)
  (when my-linux-p
    (defun sj/default-browser (&optional name)
      "Set the default browser based on the given NAME."
      (interactive
       (list
        (completing-read
         "Browser: "
         (split-string
          (shell-command-to-string
           "find /usr/share/applications ~/.local/share/applications -name \"*.desktop\" -exec grep -l \"Categories=.*WebBrowser\" {} \\;")
          "\n" t))))
      (let ((browser-desktop (file-name-nondirectory name)))
        (shell-command (format "xdg-mime default %s text/html" browser-desktop))
        (shell-command (format "xdg-mime default %s application/xhtml+xml" browser-desktop))
        (shell-command (format "xdg-mime default %s application/x-extension-html" browser-desktop))
        (shell-command (format "xdg-settings set default-web-browser %s" browser-desktop)))))

  (defun gpg-sign (&optional text)
    "Sign the given TEXT with GPG, and copy the results to the clipboard."
    (interactive "sText to sign: ")
    (let ((gpg-signature (shell-command-to-string (format "echo '%s' | gpg --clearsign --armor" text))))
      (kill-new gpg-signature)
      (message "GPG signature copied to clipboard.")))

#+end_src
#+begin_src emacs-lisp :tangle "post-init.el"
  (use-package time-zones
    :demand t)
#+end_src
** Homeassistant
#+begin_src emacs-lisp :tangle "post-init.el"
  (use-package hass
    :if (not my-phone-p)
    :ensure t
    :custom
    ;; -- Configuration goes here --
    (hass-host "192.168.7.10")
    (hass-port 8123)
    (hass-insecure t)
    (hass-apikey (lambda () (auth-source-pick-first-password :host "HomeAssistant" :user "emacs-apikey")))
    )
#+end_src
** COMMENT EAF
#+begin_src emacs-lisp :tangle "post-init.el"
  (use-package eaf
    :ensure nil
    :load-path "~/.emacs.d/site-lisp/emacs-application-framework"
    :demand t
    :custom
    ;; See https://github.com/emacs-eaf/emacs-application-framework/wiki/Customization
    (eaf-browser-continue-where-left-off t)
    (eaf-browser-enable-adblocker t)
    (browse-url-browser-function 'eaf-open-browser)
    :config
    ;; (defalias 'browse-web #'eaf-open-browser)
    ;; (eaf-bind-key scroll_up "C-n" eaf-pdf-viewer-keybinding)
    ;; (eaf-bind-key scroll_down "C-p" eaf-pdf-viewer-keybinding)
    ;; (eaf-bind-key take_photo "p" eaf-camera-keybinding)
    ;; (eaf-bind-key nil "M-q" eaf-browser-keybinding)
    )
#+end_src
* Custom Libraries
** Koreader json to org
#+begin_src emacs-lisp :tangle "srijan-lisp/koreader-json-to-org.el"
  ;;; koreader-json-to-org.el --- Convert KOReader JSON highlights to Org mode -*- lexical-binding: t; -*-

  (require 'json)
  (require 'org)

  ;;; Customization

  (defgroup koreader-json-to-org nil
    "Convert KOReader JSON highlights to Org mode.

  This package converts KOReader JSON export files into Org mode format,
  supporting both Denote-style filenames and plain filenames.

  Example configuration:
    (setq koreader-use-denote t)
    (setq koreader-denote-tag \"reading\")
    (setq koreader-add-entry-tags t)
    (setq koreader-plain-filename-template \"[%a] %t.org\")

  Use `M-x customize-group RET koreader-json-to-org' to customize."
    :group 'org
    :prefix "koreader-")

  (defcustom koreader-use-denote t
    "Whether to use Denote format for output filenames.
  When non-nil, generates filenames like: TIMESTAMP--title-author__books.org
  When nil, generates filenames like: Title - Author.org"
    :type 'boolean
    :group 'koreader-json-to-org)

  (defcustom koreader-denote-tag "books"
    "Tag to use for Denote-formatted files.
  Only used when `koreader-use-denote' is non-nil."
    :type 'string
    :group 'koreader-json-to-org)

  (defcustom koreader-add-entry-tags t
    "Whether to add tags to highlight and note entries.
  When non-nil, entries get :highlight: or :note: tags."
    :type 'boolean
    :group 'koreader-json-to-org)

  (defcustom koreader-highlight-tag "highlight"
    "Tag name for highlight entries.
  Only used when `koreader-add-entry-tags' is non-nil."
    :type 'string
    :group 'koreader-json-to-org)

  (defcustom koreader-note-tag "note"
    "Tag name for note entries.
  Only used when `koreader-add-entry-tags' is non-nil."
    :type 'string
    :group 'koreader-json-to-org)

  (defcustom koreader-plain-filename-template "%t - %a.org"
    "Template for plain (non-Denote) filenames.
  Available placeholders:
    %t - Book title
    %a - Book author
  Only used when `koreader-use-denote' is nil."
    :type 'string
    :group 'koreader-json-to-org)

  (defvar koreader-debug-logging nil
    "Enable debug logging for KOReader JSON processing.
  When non-nil, prints detailed information about file processing.")

  (defun koreader-timestamp-to-human-readable (timestamp)
    "Convert Unix TIMESTAMP to human-readable format."
    (format-time-string "%Y-%m-%d %H:%M:%S" (seconds-to-time timestamp)))

  (defun koreader-slugify (text)
    "Convert TEXT to a dash-separated slug for denote filename."
    (let* ((slug (downcase text))
           ;; Replace spaces and special characters with dashes
           (slug (replace-regexp-in-string "[^a-z0-9]+" "-" slug))
           ;; Remove leading/trailing dashes
           (slug (replace-regexp-in-string "^-+\\|-+$" "" slug)))
      slug))

  (defun koreader-find-existing-org-file (directory title author)
    "Find existing org file in DIRECTORY matching TITLE and AUTHOR.
  Returns the full path if found, nil otherwise."
    (let* ((title-slug (koreader-slugify title))
           (author-slug (koreader-slugify author))
           (pattern (concat "--" title-slug "-" author-slug "__books\\.org$"))
           (files (directory-files directory t pattern)))
      (when files
        (car files))))

  (defun koreader-generate-denote-filename (directory title author &optional timestamp)
    "Generate a denote-formatted filename for the org file.
  If a file with matching title and author exists, return that filename.
  Otherwise, generate a new one with TIMESTAMP (or current time if nil)."
    (let ((existing-file (koreader-find-existing-org-file directory title author)))
      (if existing-file
          existing-file
        (let* ((timestamp (or timestamp (format-time-string "%Y%m%dT%H%M%S")))
               (title-slug (koreader-slugify title))
               (author-slug (koreader-slugify author))
               (filename (concat timestamp "--" title-slug "-" author-slug "__books.org")))
          (expand-file-name filename directory)))))

  (defun koreader-generate-plain-filename (directory title author)
    "Generate a plain org filename using `koreader-plain-filename-template'.
  If a file with matching title and author exists, return that filename.
  Otherwise, generate a new one."
    (let* ((filename (replace-regexp-in-string
                      "%t" title
                      (replace-regexp-in-string
                       "%a" author
                       koreader-plain-filename-template)))
           (full-path (expand-file-name filename directory)))
      ;; Check if file already exists
      (if (file-exists-p full-path)
          full-path
        ;; Otherwise search for similar files using the template pattern
        (let* ((pattern (replace-regexp-in-string
                         "%t" (regexp-quote title)
                         (replace-regexp-in-string
                          "%a" (regexp-quote author)
                          (regexp-quote koreader-plain-filename-template))))
               (pattern (concat "^" pattern "$")))
          (or (car (directory-files directory t pattern t))
              full-path)))))

  (defun koreader-get-export-time-from-org (org-file)
    "Extract KOREADER_EXPORT_TIME property from ORG-FILE.
  Returns the export time as a number, or nil if not found."
    (when (file-exists-p org-file)
      (with-temp-buffer
        (insert-file-contents org-file)
        (org-mode)
        (goto-char (point-min))
        ;; Search for the property
        (when (re-search-forward "^:KOREADER_EXPORT_TIME:\\s-+\\([0-9]+\\)" nil t)
          (string-to-number (match-string 1))))))

  (defun koreader-get-processed-exports (directory)
    "Scan DIRECTORY for org files and return list of processed export times.
  Returns a list of numbers representing KOREADER_EXPORT_TIME values."
    (let ((org-files (directory-files directory t "\\.org$"))
          (export-times '()))
      (dolist (file org-files)
        (let ((export-time (koreader-get-export-time-from-org file)))
          (when export-time
            (push export-time export-times))))
      export-times))

  (defun koreader-get-json-metadata (json-file)
    "Extract metadata from JSON-FILE without full processing.
  Returns a plist with :title, :author, :created-at, :file, and :json-data.
  The :json-data can be reused to avoid re-reading the file."
    (let* ((json-data (json-read-file json-file))
           (title (alist-get 'title json-data))
           (author (alist-get 'author json-data))
           (created-at (or (alist-get 'created_on json-data) 0)))
      (list :title title
            :author author
            :created-at created-at
            :file json-file
            :json-data json-data)))

  (defun koreader-json-needs-processing-p (metadata processed-exports)
    "Check if file in METADATA needs processing.
  METADATA is a plist with :created-at field.
  PROCESSED-EXPORTS is a list of already-processed export times.
  Returns t if the file needs processing, nil otherwise."
    (let ((created-at (plist-get metadata :created-at)))
      (if (and created-at (> created-at 0))
          (not (member created-at processed-exports))
        ;; If no created_on field, always process
        t)))

  (defun koreader-add-merge-history (org-file json-file new-count skipped-count)
    "Add merge history entry to ORG-FILE's KOREADER_HISTORY drawer.
  Records timestamp, JSON-FILE basename, NEW-COUNT highlights added, and SKIPPED-COUNT existing."
    (when (file-exists-p org-file)
      (with-temp-buffer
        (insert-file-contents org-file)
        (org-mode)
        (goto-char (point-min))

        ;; Find or create the history drawer
        (let ((history-start nil)
              (json-basename (file-name-nondirectory json-file))
              (history-entry (format "- [%s] %s: Imported %d new highlights, %d skipped\n"
                                     (format-time-string "%Y-%m-%d %a %H:%M")
                                     (file-name-nondirectory json-file)
                                     new-count
                                     skipped-count)))

          ;; Search for existing KOREADER_HISTORY drawer
          (if (re-search-forward "^:KOREADER_HISTORY:" nil t)
              ;; Found existing drawer, add entry after the drawer name
              (save-excursion
                (end-of-line)
                (insert "\n" history-entry))

            ;; No drawer found, create one after PROPERTIES drawer or at beginning
            (goto-char (point-min))
            (cond
             ;; Try to insert after PROPERTIES drawer
             ((re-search-forward "^:END:" nil t)
              (end-of-line)
              (insert "\n\n:KOREADER_HISTORY:\n" history-entry ":END:"))
             ;; Otherwise insert after metadata
             (t
              (while (and (not (eobp)) (looking-at "^#\\+"))
                (forward-line 1))
              (insert "\n:KOREADER_HISTORY:\n" history-entry ":END:\n"))))

        ;; Save the modified content
        (write-region (point-min) (point-max) org-file)))))

  (defun koreader-parse-existing-org (org-file)
    "Parse ORG-FILE and return a hash table of existing entries with their content.
  Key format: \"CHAPTER|PAGE|TIMESTAMP\", value is the full entry text."
    (let ((entries-hash (make-hash-table :test 'equal)))
      (when (file-exists-p org-file)
        (with-temp-buffer
          (insert-file-contents org-file)
          (org-mode)
          (goto-char (point-min))
          ;; Skip metadata lines at the beginning
          (while (and (not (eobp)) (looking-at "^#\\+"))
            (forward-line 1))
          (let (current-chapter)
            (while (not (eobp))
              (when (org-at-heading-p)
                (let ((level (org-current-level))
                      (heading (org-get-heading t t t t)))
                  (cond
                   ;; Top-level heading is a chapter
                   ((= level 1)
                    (setq current-chapter heading))
                   ;; Second-level heading is an entry
                   ((and (= level 2) current-chapter)
                    ;; Extract page and timestamp from heading
                    ;; Format: "Page 18 - 2025-09-27 00:05:51"
                    (when (string-match "^Page \\([0-9]+\\) - \\(.+\\)" heading)
                      (let* ((page (string-to-number (match-string 1 heading)))
                             (timestamp (match-string 2 heading))
                             (key (format "%s|%d|%s" current-chapter page timestamp))
                             ;; Get the entire entry content
                             (entry-start (point))
                             (entry-end (save-excursion
                                          (org-end-of-subtree t t)
                                          (point)))
                             (entry-text (buffer-substring-no-properties entry-start entry-end)))
                        (puthash key entry-text entries-hash)))))))
              (forward-line 1)))))
      entries-hash))

  (defun koreader-entry-exists-p (chapter page timestamp entries-hash)
    "Check if an entry exists in ENTRIES-HASH.
  CHAPTER, PAGE, and TIMESTAMP identify the entry.
  Returns the entry text if it exists, nil otherwise."
    (let ((key (format "%s|%d|%s" chapter page timestamp)))
      (gethash key entries-hash)))

  (defun koreader-json-to-org (json-file &optional org-file output-directory json-data denote-timestamp)
    "Convert KOReader JSON-FILE to Org mode format.

  Uses `koreader-use-denote' to determine output format.

  Optional arguments:
  - ORG-FILE: Specific output file path (overrides filename generation)
  - OUTPUT-DIRECTORY: Directory for output file (default: same as JSON-FILE)
  - JSON-DATA: Pre-loaded JSON data to avoid re-reading file
  - DENOTE-TIMESTAMP: Timestamp string for Denote filename (ensures uniqueness)

  Returns a plist with:
  - :file - path to created/updated org file
  - :new-count - number of new highlights added
  - :skipped-count - number of existing highlights skipped
  - :export-time - created_on timestamp from JSON

  Examples:
    ;; Convert a single JSON file to the same directory
    (koreader-json-to-org \"/path/to/book.json\")

    ;; Convert to a specific output directory
    (koreader-json-to-org \"/path/to/book.json\" nil \"~/notes/books/\")

    ;; Specify exact output file
    (koreader-json-to-org \"/path/to/book.json\" \"~/notes/my-book.org\")"
    (interactive "fKOReader JSON file: ")
    (let* ((json-data (or json-data (json-read-file json-file)))
           (title (alist-get 'title json-data))
           (author (alist-get 'author json-data))
           (pages (alist-get 'number_of_pages json-data))
           (created-at (alist-get 'created_on json-data))
           (entries (append (alist-get 'entries json-data) nil)) ;; Convert vector to list
           (target-dir (or output-directory (file-name-directory json-file)))
           (output-file (or org-file
                            (if koreader-use-denote
                                (koreader-generate-denote-filename target-dir title author denote-timestamp)
                              (koreader-generate-plain-filename target-dir title author))))
           (chapters-hash (make-hash-table :test 'equal))
           (existing-entries (koreader-parse-existing-org output-file))
           (new-count 0)
           (skipped-count 0))

      ;; Group entries by chapter
      (dolist (entry entries)
        (let* ((chapter (alist-get 'chapter entry))
               (chapter-entries (gethash chapter chapters-hash)))
          (puthash chapter (append chapter-entries (list entry)) chapters-hash)))

      ;; Write to org file
      (with-temp-file output-file
        ;; Write metadata
        (insert "#+title:       " title "\n")
        (insert "#+date:        " (format-time-string "[%Y-%m-%d %a %H:%M]") "\n")
        (insert "#+book_author: " author "\n")

        ;; Denote-specific metadata
        (when koreader-use-denote
          (insert "#+filetags:    :" koreader-denote-tag ":\n")
          ;; Extract identifier from filename (timestamp part)
          (let ((identifier (if (string-match "^\\([0-9T]+\\)--" (file-name-nondirectory output-file))
                                (match-string 1 (file-name-nondirectory output-file))
                              (format-time-string "%Y%m%dT%H%M%S"))))
            (insert "#+identifier:  " identifier "\n")))

        (insert "\n")

        ;; Properties drawer
        (insert ":PROPERTIES:\n")
        (when created-at
          (insert ":KOREADER_EXPORT_TIME: " (number-to-string created-at) "\n"))
        (insert ":KOREADER_FILE: " json-file "\n")
        (insert ":PAGES: " (number-to-string pages) "\n")
        (insert ":END:\n")

        ;; Write chapters and entries
        (maphash
         (lambda (chapter entries)
           (insert "\n* " chapter "\n")
           (dolist (entry entries)
             (let* ((page (alist-get 'page entry))
                    (timestamp (alist-get 'time entry))
                    (text (alist-get 'text entry))
                    (note (alist-get 'note entry))
                    (human-time (koreader-timestamp-to-human-readable timestamp))
                    (existing-text (koreader-entry-exists-p chapter page human-time existing-entries)))

               ;; Check if entry already exists
               (if existing-text
                   (progn
                     (setq skipped-count (1+ skipped-count))
                     ;; Insert the existing entry as-is
                     (insert existing-text))
                 ;; Entry is new, add it
                 (setq new-count (1+ new-count))

                 ;; Entry heading with page number, timestamp, and tags
                 (insert "** Page " (number-to-string page) " - " human-time)
                 (when koreader-add-entry-tags
                   (let ((tag (if note
                                  (concat ":" koreader-note-tag ":")
                                (concat ":" koreader-highlight-tag ":"))))
                     (insert " " tag)))
                 (insert "\n")

                 ;; Quoted text if present
                 (when text
                   (insert "#+BEGIN_QUOTE\n")
                   (insert text "\n")
                   (insert "#+END_QUOTE\n"))

                 ;; Personal note if present
                 (when note
                   (insert "\n")
                   (insert note "\n"))

                 (insert "\n")))))
         chapters-hash))

      ;; Add merge history
      (koreader-add-merge-history output-file json-file new-count skipped-count)

      (message "Converted %s to %s (%d new, %d skipped)"
               json-file output-file new-count skipped-count)
      (when (called-interactively-p 'any)
        (find-file output-file))

      ;; Return detailed results
      (list :file output-file
            :new-count new-count
            :skipped-count skipped-count
            :export-time created-at)))

  (defun koreader-process-json-directory (json-directory output-directory)
    "Process all JSON files in JSON-DIRECTORY and output to OUTPUT-DIRECTORY.

  For each book (title+author combination), only processes the LATEST export file,
  as KOReader exports are cumulative. Skips books whose latest export has already
  been processed (based on created_on timestamp).

  Uses `koreader-use-denote' to determine the output format.

  Returns a plist with summary statistics:
  - :files-processed - number of JSON files processed
  - :files-skipped - number of JSON files skipped (old exports or already processed)
  - :total-new - total new highlights across all files
  - :total-skipped - total existing highlights across all files
  - :results - list of individual file results

  Examples:
    ;; Process all JSON files from KOReader export directory
    (koreader-process-json-directory
     \"~/koreader/exports/\"
     \"~/notes/books/\")

    ;; Check results
    (let ((results (koreader-process-json-directory
                    \"~/koreader/exports/\"
                    \"~/notes/books/\")))
      (message \"Processed %d books with %d new highlights\"
               (plist-get results :files-processed)
               (plist-get results :total-new)))"
    (let* ((json-files (directory-files json-directory t "\\.json$"))
           (processed-exports (koreader-get-processed-exports output-directory))
           (books-hash (make-hash-table :test 'equal))
           (files-to-process '())
           (files-skipped 0)
           (total-new 0)
           (total-skipped 0)
           (results '()))

      ;; Group files by book and find latest export for each
      (dolist (json-file json-files)
        (let* ((metadata (koreader-get-json-metadata json-file))
               (title (plist-get metadata :title))
               (author (plist-get metadata :author))
               (created-at (plist-get metadata :created-at))
               (book-key (concat title "|" author))
               (existing (gethash book-key books-hash)))

          ;; Debug output
          (when koreader-debug-logging
            (message "File: %s | created_at: %s"
                     (file-name-nondirectory json-file)
                     created-at))

          ;; Keep only the latest export for each book
          (when (or (not existing)
                    (> created-at (plist-get existing :created-at)))
            (when koreader-debug-logging
              (message "  -> Selected as latest for: %s" book-key))
            (puthash book-key metadata books-hash))))

      ;; Filter books that need processing (latest export not yet processed)
      (maphash
       (lambda (book-key metadata)
         (if (koreader-json-needs-processing-p metadata processed-exports)
             (push metadata files-to-process)
           (setq files-skipped (1+ files-skipped))))
       books-hash)

      ;; Count files that were skipped because they're old exports
      (setq files-skipped (+ files-skipped
                             (- (length json-files)
                                (hash-table-count books-hash))))

      ;; Process each file using cached JSON data
      ;; Track timestamp to ensure uniqueness for Denote filenames
      (let ((current-time (current-time)))
        (dolist (metadata files-to-process)
          (let* ((json-file (plist-get metadata :file))
                 (json-data (plist-get metadata :json-data))
                 (timestamp (format-time-string "%Y%m%dT%H%M%S" current-time)))
            (condition-case err
                (let ((result (koreader-json-to-org json-file nil output-directory json-data timestamp)))
                  (setq total-new (+ total-new (plist-get result :new-count)))
                  (setq total-skipped (+ total-skipped (plist-get result :skipped-count)))
                  (push result results))
              (error
               (message "Error processing %s: %s" json-file (error-message-string err))))
            ;; Increment time by 1 second for next file
            (setq current-time (time-add current-time (seconds-to-time 1))))))

      ;; Return summary
      (list :files-processed (length files-to-process)
            :files-skipped files-skipped
            :total-new total-new
            :total-skipped total-skipped
            :results (nreverse results))))

  (provide 'koreader-json-to-org)
  ;;; koreader-json-to-org.el ends here
#+end_src

